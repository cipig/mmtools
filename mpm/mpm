#!/usr/bin/perl

use warnings;
no warnings 'experimental::smartmatch';
use LWP::UserAgent;
use JSON;
use File::Slurp qw(read_file);
use File::Basename;
use List::Util qw[min max];
use Digest::SHA qw(hmac_sha256_hex hmac_sha256_base64 sha512_hex hmac_sha512_hex);
use Digest::MD5 qw(md5_hex);
use Time::HiRes;
use LWP::Protocol::socks;
use Term::ANSIColor;
#use Data::Dumper;
#use Test::JSON;

my $api = $ARGV[0];
my $base = $ARGV[1];
my $basepapid = $ARGV[2];
my $basegeckoid = $ARGV[2];
my $pubkey = $ARGV[3];
my $recvaddr = $ARGV[4];
my $recvZaddr = $ARGV[5];
my $cwd = dirname($0);
#my $useragent = "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36";
my $useragent = "Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0";
my $timeout = 20;

my $binance_apikey = "";
my $binance_seckey = "";
my $mandala_apikey = "";
my $mandala_seckey = "";
my $coinex_accessid = "";
my $coinex_seckey = "";
my $bitvavo_apikey = "";
my $bitvavo_seckey = "";
my $kucoin_apikey = "";
my $kucoin_seckey = "";
my $kucoin_passphrase = "";
my $bittrex_apikey = "";
my $bittrex_seckey = "";


sub paprika_latest_price {
    my $url = "https://api.coinpaprika.com/v1/price-converter?base_currency_id=".$_[1]."&quote_currency_id=".$_[0]."&amount=1";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub paprika_price {
    my $base = $_[0];
    my $rel = $_[1];
    my $amount = $_[2];
    my $url = "https://api.coinpaprika.com/v1/price-converter?base_currency_id=".$base."&quote_currency_id=".$rel."&amount=".$amount;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub paprika_ticker {
    my $paprika_id = $_[0];
    my $url = "https://api.coinpaprika.com/v1/tickers/".$paprika_id;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub gecko_latest_price {
    my $url = "https://api.coingecko.com/api/v3/simple/price?ids=".$_[0]."&vs_currencies=btc,usd&include_24hr_change=true";
    #print "URL: $url\n";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub safetrade_latest_price {
    my $url = "https://safe.trade/api/v2/peatio/public/markets/".$_[0]."/tickers";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub exbitron_latest_price {
    my $url = "https://api.exbitron.digital/api/v1/trading/info/".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub nestex_latest_price {
    #https://trade.nestex.one/api/cg/tickers/BKC_USDT
    my $url = "https://trade.nestex.one/api/cg/tickers/".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub ogre_latest_price {
    my $url = "https://tradeogre.com/api/v1/ticker/".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub nonkyc_latest_price {
    my $url = "https://api.nonkyc.io/api/v2/ticker/".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub nonkyc_info {
    my $url = "https://api.nonkyc.io/api/v2/asset/getbyticker/".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub mexc_latest_price {
    my $url = "https://api.mexc.com/api/v3/ticker/24hr?symbol=".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub dextrade_latest_price {
    my $url = "https://api.dex-trade.com/v1/public/ticker?pair=".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub chainlink_latest_price_eth {
    #my $url = "http://eth3.cipig.net:8555";
    my $url = "https://mainnet.gateway.tenderly.co";
    #my $url = "https://eth.merkle.io";
    #my $url = "https://rpc.payload.de";
    my $ua = LWP::UserAgent->new;
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => $url);
    $req->content_type('application/json');
    $command = '{"jsonrpc":"2.0","method": "eth_call","params":[{"to":"'.$_[0].'","data":"0x50d25bcd000000000000000000000000"},"latest"],"id":777}';
    $req->content($command);
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub chainlink_latest_price_bep {
    my $url = "http://bsc2.cipig.net:8655";
    my $ua = LWP::UserAgent->new;
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => $url);
    $req->content_type('application/json');
    $command = '{"jsonrpc":"2.0","method": "eth_call","params":[{"to":"'.$_[0].'","data":"0x50d25bcd000000000000000000000000"},"latest"],"id":777}';
    $req->content($command);
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub chainlink_latest_price_arb {
    my $url = "https://rpc.arb1.arbitrum.gateway.fm";
    my $ua = LWP::UserAgent->new;
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => $url);
    $req->content_type('application/json');
    $command = '{"jsonrpc":"2.0","method": "eth_call","params":[{"to":"'.$_[0].'","data":"0x50d25bcd000000000000000000000000"},"latest"],"id":777}';
    $req->content($command);
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub komodolive_latest_price {
    my $coin = $_[0];
    my $url = "https://myprice.cipig.net:1717/api/v1/ticker_infos";
    my $ua = LWP::UserAgent->new;
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => $url);
    #$req->content_type('application/x-www-form-urlencoded');
    $req->content_type('application/json');
    #$command = '{"expire_at":"600","ticker": "'.$coin.'"}';
    $command = '{"ticker": "'.$coin.'"}';
    $req->content($command);
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub vrscbridge_latest_price {
    my $url = "https://api.verus.services";
    my $ua = LWP::UserAgent->new;
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => $url);
    #$req->content_type('application/x-www-form-urlencoded');
    $req->content_type('application/json');
    $command = '{"jsonrpc":"1.0","id":"curltest","method":"getcurrencystate","params":["Bridge.vETH"]}';
    $req->content($command);
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif (length from_json($resp->content)->{"error"}{"code"}) {
        print "ERROR: ", from_json($resp->content)->{"error"}{"message"}, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub chipsbridge_latest_price {
    my $url = "https://api.verus.services";
    my $ua = LWP::UserAgent->new;
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => $url);
    #$req->content_type('application/x-www-form-urlencoded');
    $req->content_type('application/json');
    $command = '{"jsonrpc":"1.0","id":"curltest","method":"getcurrencystate","params":["Bridge.CHIPS"]}';
    $req->content($command);
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif (length from_json($resp->content)->{"error"}{"code"}) {
        print "ERROR: ", from_json($resp->content)->{"error"}{"message"}, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub varrrbridge_latest_price {
    my $url = "https://api.verus.services";
    my $ua = LWP::UserAgent->new;
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => $url);
    #$req->content_type('application/x-www-form-urlencoded');
    $req->content_type('application/json');
    $command = '{"jsonrpc":"1.0","id":"curltest","method":"getcurrencystate","params":["Bridge.vARRR"]}';
    $req->content($command);
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif (length from_json($resp->content)->{"error"}{"code"}) {
        print "ERROR: ", from_json($resp->content)->{"error"}{"message"}, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub vdexbridge_latest_price {
    my $url = "https://api.verus.services";
    my $ua = LWP::UserAgent->new;
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => $url);
    #$req->content_type('application/x-www-form-urlencoded');
    $req->content_type('application/json');
    $command = '{"jsonrpc":"1.0","id":"curltest","method":"getcurrencystate","params":["Bridge.vDEX"]}';
    $req->content($command);
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif (length from_json($resp->content)->{"error"}{"code"}) {
        print "ERROR: ", from_json($resp->content)->{"error"}{"message"}, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub komodolive_usdrates {
    my $url = "http://prices.cipig.net:3337/api/v1/usd_rates";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            #print Dumper($resp->content);
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub freiexchange_latest_price {
    my $url = "https://api.freiexchange.com/public/ticker";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub dex_ticker_24h {
    my $url = "https://dexapi.cipig.net/public/ticker_24h.php?market=".$_[0]."-".$_[1];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub binance_latest_price {
    my $symbol = $_[0];
    my $url = "https://api.binance.com/api/v3/ticker/price?symbol=".$symbol;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}

sub binance_info {
    my $symbol = $_[0];
    my $url = "https://api.binance.com/api/v3/exchangeInfo?symbol=".$symbol;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}

sub binance_book_price {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.binance.com/api/v3/ticker/bookTicker?symbol=".$base.$coin;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub binance_24hr_price {
    my $url = "https://api.binance.com/api/v3/ticker/24hr?symbol=".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub binance_xxhr_price {
    my $url = "https://api.binance.com/api/v3/ticker?symbol=".$_[0]."&windowSize=4h";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub kucoin_latest_price {
    my $url = "https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return decode_json($resp->content)->{'data'};
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub kucoin_book_price {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=".$base."-".$coin;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return decode_json($resp->content)->{'data'};
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub bitvavo_book_price {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.bitvavo.com/v2/ticker/book?market=".$base."-".$coin;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub binance_kline {
    my $base = $_[0];
    my $coin = $_[1];
    my $interval = $_[2];
    my $limit = $_[3];
    my $url = "https://api.binance.com/api/v3/klines?symbol=".$base.$coin."&interval=".$interval."&limit=".$limit;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub coinex_latest_price {
    my $url = "https://api.coinex.com/v1/market/ticker?market=".$_[0];
    #my $url = "https://api.coinex.com/v2/spot/ticker?market=".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}

sub coinex_info {
    #my $url = "https://api.coinex.com/v1/common/asset/config?coin_type=".$_[0];
    my $url = "https://api.coinex.com/v2/assets/deposit-withdraw-config?ccy=".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
    my $json_out = eval { decode_json($resp->content) };
    if ($@) {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    } elsif ($resp->is_success) {
        return $resp->content;
    } else {
        print "HTTP GET url: ", $url, "\n";
        print "HTTP GET error code: ", $resp->code, "\n";
        print "HTTP GET error message: ", $resp->message, "\n";
        return 1;
    }
}


sub hitbtc_latest_price {
    my $url = "https://api.hitbtc.com/api/2/public/ticker/".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub bithumb_latest_price {
    my $url = "https://global-openapi.bithumb.pro/openapi/v1/spot/ticker?symbol=".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub binance_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.binance.com/api/v3/depth?symbol=".$base.$coin."&limit=100";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub kucoin_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.kucoin.com/api/v1/market/orderbook/level2_100?symbol=".$base."-".$coin;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return decode_json($resp->content)->{'data'};
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub bitvavo_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.bitvavo.com/v2/".$base."-".$coin."/book";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub bittrex_depth {
    my $url = "https://api.bittrex.com/v3/markets/".$_[0]."/orderbook";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}

sub bittrex_latest_price {
    my $url = "https://api.bittrex.com/v3/markets/".$_[0]."/ticker";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}

sub bittrex_summary {
    my $url = "https://api.bittrex.com/v3/markets/".$_[0]."/summary";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}

sub bittrex_info {
    my $url = "https://api.bittrex.com/v3/currencies/".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub bittrex_cancelorders {
    my $timestamp = time()*1000;
    my $url = "https://api.bittrex.com/v3/orders/open?marketSymbol=$_[0]-$_[1]";
    my $body = "";
    my $content_hash = sha512_hex($body);
    my $signature = hmac_sha512_hex($timestamp.$url."DELETE".$content_hash, $bittrex_seckey);
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(DELETE => $url);
    $req->header('Api-Key' => $bittrex_apikey);
    $req->header('Api-Timestamp' => $timestamp);
    $req->header('Api-Content-Hash' => $content_hash);
    $req->header('Api-Signature' => $signature);
    $req->header('content-type' => 'application/json');
    $req->content($body);
    $resp = $ua->request($req);
}


sub bittrex_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = undef;
    my $ask = undef;
    if (($coin eq "EUR") || ($coin eq "USDT")) {
        $bid = sprintf("%.3f",$_[2]);
        $ask = sprintf("%.3f",$_[3]);
    } else {
        $bid = sprintf("%.8f",$_[2]);
        $ask = sprintf("%.8f",$_[3]);
    }
    my $quantity = sprintf("%.3f",$_[4]);

    if ( $base eq "BTC" ) {
        print "$base/$coin ".sprintf("%.3f",$quantity);
    } else {
        print "$base/$coin ".sprintf("%04d",$quantity);
    }

    my $timestamp = time()*1000;
    my $url = "https://api.bittrex.com/v3/orders";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => $url);

    if ( defined $bid ) {
        my $body = '{"marketSymbol":"'.$base.'-'.$coin.'","direction":"BUY","limit":"'.$bid.'","quantity":"'.$quantity.'","type":"LIMIT","timeInForce":"POST_ONLY_GOOD_TIL_CANCELLED","useAwards":false}';
        my $content_hash = sha512_hex($body);
        my $signature = hmac_sha512_hex($timestamp.$url."POST".$content_hash, $bittrex_seckey);
        $req->header('Api-Key' => $bittrex_apikey);
        $req->header('Api-Timestamp' => $timestamp);
        $req->header('Api-Content-Hash' => $content_hash);
        $req->header('Api-Signature' => $signature);
        $req->header('content-type' => 'application/json');
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " bid ".$bid;
        } else {
            print " bid ".$resp->content;
        }
    }

    if ( defined $ask ) {
        my $body = '{"marketSymbol":"'.$base.'-'.$coin.'","direction":"SELL","limit":"'.$ask.'","quantity":"'.$quantity.'","type":"LIMIT","timeInForce":"POST_ONLY_GOOD_TIL_CANCELLED","useAwards":false}';
        my $content_hash = sha512_hex($body);
        my $signature = hmac_sha512_hex($timestamp.$url."POST".$content_hash, $bittrex_seckey);
        $req->header('Api-Key' => $bittrex_apikey);
        $req->header('Api-Timestamp' => $timestamp);
        $req->header('Api-Content-Hash' => $content_hash);
        $req->header('Api-Signature' => $signature);
        $req->header('content-type' => 'application/json');
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " ask ".$ask."\n";
        } else {
            print " ask ".$resp->content."\n";
        }
    }
}


sub coinex_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.coinex.com/v1/market/depth?market=".$base.$coin."&limit=10&merge=0";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return decode_json($resp->content)->{'data'};
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub binance_getorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $command = "symbol=".$base.$coin."&recvWindow=15000&timestamp=".time()*1000;
    my $signature = hmac_sha256_hex($command, $binance_seckey);
    my $url = "https://api.binance.com/api/v3/openOrders?".$command."&signature=".$signature;

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('X-MBX-APIKEY' => $binance_apikey);
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub binance_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(DELETE => 'https://api.binance.com/api/v3/order');
    $req->header('X-MBX-APIKEY' => $binance_apikey);

    my $binance_orders = binance_getorders($base,$coin);
    if ( $binance_orders ne "1" ) {
        my $orders = decode_json($binance_orders);
        foreach my $order( @$orders ) {
            my $orderid = $order->{'clientOrderId'};
            $command = "symbol=".$base.$coin."&origClientOrderId=".$orderid."&recvWindow=15000&timestamp=".time()*1000;
            $signature = hmac_sha256_hex($command, $binance_seckey);
            $body = $command."&signature=".$signature;
            $req->content($body);
            $resp = $ua->request($req);
            #print $resp->content."\n";
        }
    }
}


sub kucoin_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];
    my $tonce = time()*1000;
    my $endpoint = "/api/v1/orders?symbol=".$base."-".$coin;
    my $url = "https://api.kucoin.com".$endpoint;

    my $prehash = $tonce."DELETE".$endpoint; # {timestamp+method+endpoint+body}
    my $apisign = hmac_sha256_base64($prehash, $kucoin_seckey);
    while (length($apisign) % 4) {
        $apisign .= '=';
    }
    my $passphrase = hmac_sha256_base64($kucoin_passphrase, $kucoin_seckey); #  Encrypt passphrase with HMAC-sha256 via API-Secret --> Encode contents by base64 before you pass the request
    while (length($passphrase) % 4) {
        $passphrase .= '=';
    }

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(DELETE => $url);
    $req->header('KC-API-KEY-VERSION' => '2');
    $req->header('KC-API-KEY' => $kucoin_apikey);
    $req->header('KC-API-SIGN' => $apisign);
    $req->header('KC-API-TIMESTAMP' => $tonce);
    $req->header('KC-API-PASSPHRASE' => $passphrase);
    $req->header('content-type' => 'application/json');
    $req->content();
    $resp = $ua->request($req);
    #print $resp->content;
}


sub mandala_getorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $command = "symbol=".$base."_".$coin."&type=1&recvWindow=15000&timestamp=".time()*1000;
    my $signature = hmac_sha256_hex($command, $mandala_seckey);
    my $url = "https://trade.mandala.exchange/open/v1/orders?".$command."&signature=".$signature;

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('X-MBX-APIKEY' => $mandala_apikey);
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub mandala_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(POST => 'https://trade.mandala.exchange/open/v1/orders/cancel');
    $req->header('X-MBX-APIKEY' => $mandala_apikey);
    $req->header('content-type' => 'application/x-www-form-urlencoded');

    my $mandala_orders = mandala_getorders($base,$coin);
    if ( $mandala_orders ne "1" ) {
        my $orders = decode_json($mandala_orders)->{'data'}{'list'};
        foreach my $order( @$orders ) {
            my $orderid = $order->{'orderId'};
            $command = "orderId=".$orderid."&recvWindow=15000&timestamp=".time()*1000;
            $signature = hmac_sha256_hex($command, $mandala_seckey);
            $body = $command."&signature=".$signature;
            $req->content($body);
            $resp = $ua->request($req);
            #print $resp->content."\n";
        }
    }
}


sub bitvavo_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $timestamp = time()*1000;
    my $url = "https://api.bitvavo.com/v2/orders";
    my $params = "?market=".$base."-".$coin;
    my $command = $timestamp."DELETE/v2/orders".$params;
    my $signature = hmac_sha256_hex($command, $bitvavo_seckey);
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(DELETE => $url.$params);
    $req->header('BITVAVO-ACCESS-KEY' => $bitvavo_apikey);
    $req->header('BITVAVO-ACCESS-SIGNATURE' => $signature);
    $req->header('BITVAVO-ACCESS-TIMESTAMP' => $timestamp);
    $req->header('content-type' => 'application/json');
    $req->content();
    $resp = $ua->request($req);
    #print $resp->content."\n";
}


sub coinex_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];
    my $tonce = time()*1000;
    my $url = "https://api.coinex.com/v1/order/pending?";
    my $params = "access_id=".$coinex_accessid."&account_id=0&market=".$base.$coin."&tonce=".$tonce;
    my $authorization = uc(md5_hex($params."&secret_key=".$coinex_seckey));

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(DELETE => $url.$params);
    $req->header('authorization' => $authorization);
    $req->header('content-type' => 'application/json');
    $req->content();
    $resp = $ua->request($req);
    #print $resp->content;
}


sub binance_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = undef;
    my $ask = undef;
    if ((($coin eq "BUSD") || ($coin eq "USDT")) && ($base eq "DGB")) {
        $bid = sprintf("%.5f",$_[2]);
        $ask = sprintf("%.5f",$_[3]);
    } elsif ((($coin eq "BUSD") || ($coin eq "USDT") || ($coin eq "USDC")) && ($base eq "LTC")) {
        $bid = sprintf("%.2f",$_[2]);
        $ask = sprintf("%.2f",$_[3]);
    } elsif ( $base eq "BTC" ) {
        $bid = sprintf("%.2f",$_[2]);
        $ask = sprintf("%.2f",$_[3]);
    } elsif (($coin eq "BTC") && ($base eq "LTC")) {
        $bid = sprintf("%.6f",$_[2]);
        $ask = sprintf("%.6f",$_[3]);
    } elsif (( $coin eq "BUSD" ) || ( $coin eq "USDT" ) || ( $coin eq "BNB" )) {
        $bid = sprintf("%.4f",$_[2]);
        $ask = sprintf("%.4f",$_[3]);
    } elsif ( $coin eq "ETH" ) {
        $bid = sprintf("%.7f",$_[2]);
        $ask = sprintf("%.7f",$_[3]);
    } else {
        $bid = sprintf("%.8f",$_[2]);
        $ask = sprintf("%.8f",$_[3]);
    }
    my $quantity = sprintf("%.3f",$_[4]);

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'https://api.binance.com/api/v3/order');
    $req->header('X-MBX-APIKEY' => $binance_apikey);

    if ( $base eq "LTC" ) {
        print "$base/$coin ".sprintf("%.1f",$quantity);
    } elsif ( $base eq "BTC" ) {
        print "$base/$coin ".sprintf("%.3f",$quantity);
    } else {
        print "$base/$coin ".sprintf("%04d",$quantity);
    }

    if ( defined $bid ) {
        my $command = "symbol=".$base.$coin."&side=BUY&type=LIMIT_MAKER&newOrderRespType=RESULT&quantity=".$quantity."&price=".$bid."&newClientOrderId=buy".$coin.$base.sprintf("%u",$quantity*1000)."&recvWindow=15000&timestamp=".time()*1000;
        my $signature = hmac_sha256_hex($command, $binance_seckey);
        my $body = $command."&signature=".$signature;
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " bid ".$bid;
        } else {
            print " bid ".$resp->content;
        }
    }

    if ( defined $ask ) {
	my $command = "symbol=".$base.$coin."&side=SELL&type=LIMIT_MAKER&newOrderRespType=RESULT&quantity=".$quantity."&price=".$ask."&newClientOrderId=sell".$coin.$base.sprintf("%u",$quantity*1000)."&recvWindow=15000&timestamp=".time()*1000;
	my $signature = hmac_sha256_hex($command, $binance_seckey);
        my $body = $command."&signature=".$signature;
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " ask ".$ask."\n";
        } else {
            print " ask ".$resp->content."\n";
        }
    }
}


sub kucoin_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = undef;
    my $ask = undef;
    if (( $coin eq "BUSD" ) || ( $coin eq "USDT" ) || ( $coin eq "EUR" )) {
        $bid = sprintf("%.4f",$_[2]);
        $ask = sprintf("%.4f",$_[3]);
    } elsif (( $coin eq "BTC" ) && ( $base eq "KMD" )) {
        $bid = sprintf("%.9f",$_[2]);
        $ask = sprintf("%.9f",$_[3]);
    } else {
        $bid = sprintf("%.8f",$_[2]);
        $ask = sprintf("%.8f",$_[3]);
    }
    my $quantity = sprintf("%u",$_[4]);

    my $endpoint = "/api/v1/orders";
    my $url = "https://api.kucoin.com".$endpoint;

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'https://api.kucoin.com/api/v1/orders');

    print "$base/$coin ".sprintf("%04d",$quantity);

    if ( defined $ask ) {
        my $tonce = time()*1000;
        my $body = '{"clientOid":"sell'.$base.$coin.$quantity.'","side":"sell","symbol":"'.$base.'-'.$coin.'","type":"limit","price":'.$ask.',"size":'.$quantity.'}';
        my $prehash = $tonce."POST".$endpoint.$body; # {timestamp+method+endpoint+body}
        my $apisign = hmac_sha256_base64($prehash, $kucoin_seckey);
        while (length($apisign) % 4) {
            $apisign .= '=';
        }
        my $passphrase = hmac_sha256_base64($kucoin_passphrase, $kucoin_seckey); #  Encrypt passphrase with HMAC-sha256 via API-Secret --> Encode contents by base64 before you pass the request
        while (length($passphrase) % 4) {
            $passphrase .= '=';
        }
        $req->header('KC-API-KEY-VERSION' => '2');
        $req->header('KC-API-KEY' => $kucoin_apikey);
        $req->header('KC-API-SIGN' => $apisign);
        $req->header('KC-API-TIMESTAMP' => $tonce);
        $req->header('KC-API-PASSPHRASE' => $passphrase);
        $req->header('content-type' => 'application/json');

        $req->content($body);
        my $resp = $ua->request($req);
        my $resp_code = decode_json($resp->content)->{'code'};
        if ($resp_code eq "200000") {
            print " ask ".$ask;
        } else {
            print " ask ".decode_json($resp->content)->{'msg'};
        }

    }

    if ( defined $bid ) {
        my $tonce = time()*1000;
        my $body = '{"clientOid":"buy'.$base.$coin.$quantity.'","side":"buy","symbol":"'.$base.'-'.$coin.'","type":"limit","price":'.$bid.',"size":'.$quantity.'}';
        my $prehash = $tonce."POST".$endpoint.$body; # {timestamp+method+endpoint+body}
        my $apisign = hmac_sha256_base64($prehash, $kucoin_seckey);
        while (length($apisign) % 4) {
            $apisign .= '=';
        }
        my $passphrase = hmac_sha256_base64($kucoin_passphrase, $kucoin_seckey); #  Encrypt passphrase with HMAC-sha256 via API-Secret --> Encode contents by base64 before you pass the request
        while (length($passphrase) % 4) {
            $passphrase .= '=';
        }
        $req->header('KC-API-KEY-VERSION' => '2');
        $req->header('KC-API-KEY' => $kucoin_apikey);
        $req->header('KC-API-SIGN' => $apisign);
        $req->header('KC-API-TIMESTAMP' => $tonce);
        $req->header('KC-API-PASSPHRASE' => $passphrase);
        $req->header('content-type' => 'application/json');

        $req->content($body);
        my $resp = $ua->request($req);
        my $resp_code = decode_json($resp->content)->{'code'};
        if ($resp_code eq "200000") {
            print " bid ".$bid."\n";
        } else {
            print " bid ".decode_json($resp->content)->{'msg'}."\n";
        }

    }
}


sub mandala_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = undef;
    my $ask = undef;
    if ((($coin eq "BUSD") || ($coin eq "USDT")) && ($base eq "DGB")) {
        $bid = sprintf("%.5f",$_[2]);
        $ask = sprintf("%.5f",$_[3]);
    } elsif ((($coin eq "BUSD") || ($coin eq "USDT") || ($coin eq "TUSD")) && ($base eq "LTC")) {
        $bid = sprintf("%.2f",$_[2]);
        $ask = sprintf("%.2f",$_[3]);
    } elsif (($coin eq "BTC") && ($base eq "LTC")) {
        $bid = sprintf("%.6f",$_[2]);
        $ask = sprintf("%.6f",$_[3]);
    } elsif (( $coin eq "BUSD" ) || ( $coin eq "USDT" ) || ( $coin eq "BNB" )) {
        $bid = sprintf("%.4f",$_[2]);
        $ask = sprintf("%.4f",$_[3]);
    } elsif ( $coin eq "ETH" ) {
        $bid = sprintf("%.7f",$_[2]);
        $ask = sprintf("%.7f",$_[3]);
    } else {
        $bid = sprintf("%.8f",$_[2]);
        $ask = sprintf("%.8f",$_[3]);
    }
    my $quantity = sprintf("%.2f",$_[4]);

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'https://trade.mandala.exchange/open/v1/orders');
    $req->header('X-MBX-APIKEY' => $mandala_apikey);
    $req->header('content-type' => 'application/x-www-form-urlencoded');

    if ( $base eq "LTC" ) {
        print "$base/$coin ".sprintf("%.1f",$quantity);
    } else {
        print "$base/$coin ".sprintf("%04d",$quantity);
    }

    if ( defined $bid ) {
        my $command = "symbol=".$base."_".$coin."&side=0&type=1&quantity=".$quantity."&price=".$bid."&clientId=buy".$coin.$base.sprintf("%u",$quantity*1000)."&recvWindow=15000&timestamp=".time()*1000;
        my $signature = hmac_sha256_hex($command, $mandala_seckey);
        my $body = $command."&signature=".$signature;
        $req->content($body);
        my $resp = $ua->request($req);
        my $resp_code = decode_json($resp->content)->{'code'};
        if ($resp_code eq "0") {
            print " bid ".$bid;
        } else {
            print " bid ".decode_json($resp->content)->{'msg'};
        }
    }

    if ( defined $ask ) {
        my $command = "symbol=".$base."_".$coin."&side=1&type=1&quantity=".$quantity."&price=".$ask."&clientId=sell".$coin.$base.sprintf("%u",$quantity*1000)."&recvWindow=15000&timestamp=".time()*1000;
        my $signature = hmac_sha256_hex($command, $mandala_seckey);
        my $body = $command."&signature=".$signature;
        $req->content($body);
        my $resp = $ua->request($req);
        my $resp_code = decode_json($resp->content)->{'code'};
        if ($resp_code eq "0") {
            print " ask ".$ask."\n";
        } else {
            print " ask ".decode_json($resp->content)->{'msg'}."\n";
        }
    }
}


sub bitvavo_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = $_[2];
    my $ask = $_[3];
    if ( ($ask < 1) && ($bid < 1) ) {
        $bid = sprintf("%.5f",$_[2]);
        $ask = sprintf("%.5f",$_[3]);
    } else {
        $bid = sprintf("%.4f",$_[2]);
        $ask = sprintf("%.4f",$_[3]);
    }
    my $quantity = sprintf("%u",$_[4]);

    my $timestamp = time()*1000;
    my $url = "https://api.bitvavo.com/v2/order";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => $url);

    print "$base/$coin ".sprintf("%04d",$quantity);

    if ( defined $bid ) {
        my $body = '{"market":"'.$base.'-'.$coin.'","side":"buy","price":"'.$bid.'","amount":"'.$quantity.'","orderType":"limit","postOnly":true,"responseRequired":false}';
        my $command = $timestamp."POST/v2/order".$body;
        my $signature = hmac_sha256_hex($command, $bitvavo_seckey);
        $req->header('BITVAVO-ACCESS-KEY' => $bitvavo_apikey);
        $req->header('BITVAVO-ACCESS-SIGNATURE' => $signature);
        $req->header('BITVAVO-ACCESS-TIMESTAMP' => $timestamp);
        $req->header('content-type' => 'application/json');
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " bid ".$bid;
        } else {
            print " bid 0.00000";
            print " ".$resp->content;
        }
    }

    if ( defined $ask ) {
        my $body = '{"market":"'.$base.'-'.$coin.'","side":"sell","price":"'.$ask.'","amount":"'.$quantity.'","orderType":"limit","postOnly":true,"responseRequired":false}';
        my $command = $timestamp."POST/v2/order".$body;
        my $signature = hmac_sha256_hex($command, $bitvavo_seckey);
        $req->header('BITVAVO-ACCESS-KEY' => $bitvavo_apikey);
        $req->header('BITVAVO-ACCESS-SIGNATURE' => $signature);
        $req->header('BITVAVO-ACCESS-TIMESTAMP' => $timestamp);
        $req->header('content-type' => 'application/json');
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " ask ".$ask."\n";
        } else {
            print " ask 0.00000\n";
            print " ".$resp->content."\n";
        }
    }
}


sub coinex_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = undef;
    my $ask = undef;
    if ( ($base eq "ARRR") && ($coin eq "USDT") ) {
        $bid = sprintf("%.4f",$_[2]);
        $ask = sprintf("%.4f",$_[3]);
    } elsif ( $coin eq "USDT" ) {
        $bid = sprintf("%.6f",$_[2]);
        $ask = sprintf("%.6f",$_[3]);
    } else {
        $bid = sprintf("%.10f",$_[2]);
        $ask = sprintf("%.10f",$_[3]);
    }
    my $quantity = sprintf("%u",$_[4]);
    my $url = "https://api.coinex.com/v1/order/limit";

    print "$base/$coin ".sprintf("%03d",$quantity);

    if ( defined $bid ) {
        my $tonce = time()*1000;
        my $body = '{ "access_id":"'.$coinex_accessid.'","amount":"'.$quantity.'","price":"'.$bid.'","type":"buy","market":"'.$base.$coin.'","tonce":'.$tonce.' }';
        my $signtext = "access_id=".$coinex_accessid."&amount=".$quantity."&market=".$base.$coin."&price=".$bid."&tonce=".$tonce."&type=buy&secret_key=".$coinex_seckey;
        my $authorization = uc(md5_hex($signtext));

        my $ua = LWP::UserAgent->new;
        $ua->agent($useragent);
        $ua->timeout($timeout);
        $req = HTTP::Request->new(POST => $url);
        $req->header('authorization' => $authorization);
        $req->header('content-type' => 'application/json');
        $req->content($body);
        $resp = $ua->request($req);
        my $code = decode_json($resp->content)->{'code'};
        if ($code eq "0") {
            print " bid ".$bid;
        } else {
            print " bid 0.00000000";
            print " ".$resp->content;
        }
    }

    if ( defined $ask ) {
        my $tonce = time()*1000;
        my $body = '{ "access_id":"'.$coinex_accessid.'","amount":"'.$quantity.'","price":"'.$ask.'","type":"sell","market":"'.$base.$coin.'","tonce":'.$tonce.' }';
        my $signtext = "access_id=".$coinex_accessid."&amount=".$quantity."&market=".$base.$coin."&price=".$ask."&tonce=".$tonce."&type=sell&secret_key=".$coinex_seckey;
        my $authorization = uc(md5_hex($signtext));

        my $ua = LWP::UserAgent->new;
        $ua->agent($useragent);
        $ua->timeout($timeout);
        $req = HTTP::Request->new(POST => $url);
        $req->header('authorization' => $authorization);
        $req->header('content-type' => 'application/json');
        $req->content($body);
        $resp = $ua->request($req);
        my $code = decode_json($resp->content)->{'code'};
        if ($code eq "0") {
            print " ask ".$ask."\n";
        } else {
            print " ask 0.00000000\n";
            print " ".$resp->content."\n";
        }
    }
}


sub dex_setprice {
    my $base = $_[0];
    my $rel = $_[1];
    my $bid = $_[2];
    my $ask = $_[3];
    my $maxbidvolume = $_[4];
    my $minbidvolume = $_[5];
    my $maxaskvolume = $_[6];
    my $minaskvolume = $_[7];
    my $bidmargin = $_[8];
    my $askmargin = $_[9];
    my $coinusdprice = $_[10];
    my $rel_mintradevol = $_[11];
    my $base_mintradevol = $_[12];
    my $rel_balance = $_[13];
    my $base_balance = $_[14];

    my $ua = LWP::UserAgent->new;
    #$ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    print "$rel/$base  ";

    if ( defined $bid ) {
        my $command = undef;
        my $bidvolume1 = 0;
        if ( defined $maxbidvolume ) {
            $bidvolume1 = $maxbidvolume;
            if ($bidvolume1 > $base_balance*0.95) { $bidvolume1 = $base_balance*0.95; }
        } else {
            $bidvolume1 = $base_balance*0.95;
        }
        if ( $bidvolume1 > 0 ) {
            if ( defined $minbidvolume ) {
                my $minbidvolume = $minbidvolume * (1 - $bidmargin);
                if (($minbidvolume < $base_mintradevol) || ($minbidvolume < $rel_mintradevol/$bid)) { $minbidvolume = max($base_mintradevol,$rel_mintradevol/$bid)*1.01; }
                $command = '{"userpass":"'.$userpass.'","method":"setprice","timeout_in_minutes":15,"save_in_history":false,"base":"'.$base.'","rel":"'.$rel.'","price":'.$bid.',"volume":'.$bidvolume1.',"min_volume":'.$minbidvolume.'}';
            } else {
                $command = '{"userpass":"'.$userpass.'","method":"setprice","timeout_in_minutes":15,"save_in_history":false,"base":"'.$base.'","rel":"'.$rel.'","price":'.$bid.',"volume":'.$bidvolume1.'}';
            }
            $req->content($command);
            my $resp1 = $ua->request($req);
            if ($resp1->is_success) {
                print "bid ".sprintf("%.8f",1/$bid)."  ";
            } else {
                my $biderror = eval {from_json($resp1->content)->{'error'}};
                if ($@) { print "unknown error $@"; } else { print $biderror."  "; }
            }
        }
    } else {
        $command = '{"userpass":"'.$userpass.'","method":"cancel_all_orders","cancel_by":{"type":"Pair","data":{"base":"'.$base.'","rel":"'.$rel.'"}}}';
        $req->content($command);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print "bid deleted  ";
        } else {
            my $biderror = eval {from_json($resp->content)->{'error'}};
            if ($@) { print "unknown error $@"; } else { print $biderror."  "; }
        }
    }

    Time::HiRes::sleep(0.5);

    if ( defined $ask ) {
        my $command = undef;
        my $askvolume1 = 0;
        if ( defined $maxaskvolume ) {
            $askvolume1 = $maxaskvolume;
            if ($askvolume1 > $rel_balance*0.95) { $askvolume1 = $rel_balance*0.95; }
        } else {
            $askvolume1 = $rel_balance*0.95;
        }
        if ( $askvolume1 > 0 ) {
            if ( defined $minaskvolume ) {
                my $minaskvolume = $minaskvolume * (1 - $askmargin);
                if (($minaskvolume < $rel_mintradevol) || ($minaskvolume < $base_mintradevol/$ask)) { $minaskvolume = max($rel_mintradevol,$base_mintradevol/$ask)*1.01; }
                $command = '{"userpass":"'.$userpass.'","method":"setprice","timeout_in_minutes":15,"save_in_history":false,"base":"'.$rel.'","rel":"'.$base.'","price":'.$ask.',"volume":'.$askvolume1.',"min_volume":'.$minaskvolume.'}';
            } else {
                $command = '{"userpass":"'.$userpass.'","method":"setprice","timeout_in_minutes":15,"save_in_history":false,"base":"'.$rel.'","rel":"'.$base.'","price":'.$ask.',"volume":'.$askvolume1.'}';
            }
            $req->content($command);
            $resp1 = $ua->request($req);
            if ($resp1->is_success) {
                print "ask ".sprintf("%.8f",$ask)." ";
            } else {
                my $askerror = eval {from_json($resp1->content)->{'error'}};
                if ($@) { print "unknown error $@"; } else { print $askerror." "; }
            }
        }
    } else {
        $command = '{"userpass":"'.$userpass.'","method":"cancel_all_orders","cancel_by":{"type":"Pair","data":{"base":"'.$rel.'","rel":"'.$base.'"}}}';
        $req->content($command);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print "ask deleted ";
        } else {
            my $askerror = eval {from_json($resp->content)->{'error'}};
            if ($@) { print "unknown error $@"; } else { print $askerror." "; }
        }
    }

    my $rel_balance_usd = $rel_balance * $coinusdprice;
    if ( $rel_balance_usd > 1000 ) {
        print colored (" balance_in_usd ".sprintf("%.2f",$rel_balance_usd), 'red'),"\n";
    } elsif ( $rel_balance_usd > 500 ) {
        print colored (" balance_in_usd ".sprintf("%.2f",$rel_balance_usd), 'yellow'),"\n";
    } elsif ( $rel_balance_usd > 200 ) {
        print colored (" balance_in_usd ".sprintf("%.2f",$rel_balance_usd), 'green'),"\n";
    } else {
        print " balance_in_usd ".sprintf("%.2f",$rel_balance_usd)."\n";
    }
}


sub dex_deleteprice_pair {
    my $ua = LWP::UserAgent->new;
    #$ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    $command = '{"userpass":"'.$userpass.'","method":"cancel_all_orders","cancel_by":{"type":"Pair","data":{"base":"'.$_[1].'","rel":"'.$_[0].'"}}}';
    $req->content($command);
    my $resp = $ua->request($req);
    if ($resp->is_success) {
        print "$_[1]/$_[0]  bid deleted ";
    } else {
        my $biderror = eval {from_json($resp->content)->{'error'}};
        if ($@) { print "unknown error $@"; } else { print $biderror." "; }
    }

    $command = '{"userpass":"'.$userpass.'","method":"cancel_all_orders","cancel_by":{"type":"Pair","data":{"base":"'.$_[0].'","rel":"'.$_[1].'"}}}';
    $req->content($command);
    $resp = $ua->request($req);
    if ($resp->is_success) {
        print " ask deleted\n";
    } else {
        my $askerror = eval {from_json($resp->content)->{'error'}};
        if ($@) { print "unknown error $@"; } else { print $askerror; }
    }
}


sub dex_deleteprice_ticker {
    my $ua = LWP::UserAgent->new;
    #$ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    $command = '{"userpass":"'.$userpass.'","method":"cancel_all_orders","cancel_by":{"type":"Coin","data":{"ticker":"'.$_[0].'"}}}';
    $req->content($command);
    $resp = $ua->request($req);
    if ($resp->is_success) {
        print " ".$resp->content."\n";
    } else {
        my $error = eval {from_json($resp->content)->{'error'}};
        if ($@) { print "unknown error $@"; } else { print $error; }
    }
}


sub dex_gettradefee {
    my $coin = $_[0];
    my $ua = LWP::UserAgent->new;
    #$ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    $command = '{"userpass":"'.$userpass.'","method":"get_trade_fee","coin":"'.$coin.'"}';
    $req->content($command);
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return from_json($resp->content)->{'result'}{'amount'};
        } else {
            print "get_trade_fee for $coin error\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub dex_myorders {
    my $base = $_[0];
    my $rel = $_[1];
    my $ua = LWP::UserAgent->new;
    #$ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    $command = '{"userpass":"'.$userpass.'","method":"my_orders"}';
    $req->content($command);
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return from_json($resp->content)->{'result'}{'maker_orders'};
        } else {
            print "my_orders for $base/$rel error\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub dex_getbalance {
    my $coin = $_[0];
    my $ua = LWP::UserAgent->new;
    #$ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    $command = '{"userpass":"'.$userpass.'","method":"my_balance","coin":"'.$coin.'"}';
    $req->content($command);
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return from_json($resp->content)->{'balance'};
        } else {
            print "================= my_balance for $coin error\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            #print "HTTP GET error message: ", $resp->message, "\n";
            #print Dumper($resp->content);
            return 0;
        }
}


sub dex_getmintradevol {
    my $coin = $_[0];
    my $ua = LWP::UserAgent->new;
    #$ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    $command = '{"userpass":"'.$userpass.'","method":"min_trading_vol","coin":"'.$coin.'"}';
    $req->content($command);
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return from_json($resp->content)->{'result'}{'min_trading_vol'};
        } else {
            #print "min_trading_vol for $coin error\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            #print "HTTP GET error message: ", $resp->message, "\n";
            #print Dumper($resp->content);
            return 0;
        }
}


sub calc_bestprice {
    my $quantity = $_[1];
    my $coin = $_[2];
    foreach (@{$_[0]}) {
        my @array = $_;
        my $price = $array[0][0];
        my $volume = $array[0][1];
        if ( $volume >= $quantity ) {
            return $price;
            last;
        }
    }
}


sub calc_bestprice_sum {
    my $sum = 0;
    my $maxsum = $_[1];
    my $coin = $_[2];
    foreach (@{$_[0]}) {
        my @array = $_;
        my $price = $array[0][0];
        my $volume = $array[0][1];
        $sum += $volume;
        if ( $sum >= $maxsum ) {
            return $price;
            last;
        }
    }
}


sub calc_bestprice_sum_bittrex {
    my $sum = 0;
    my $maxsum = $_[1];
    my $coin = $_[2];
    foreach (@{$_[0]}) {
        my @array = $_;
        my $price = $array[0]{"rate"};
        my $volume = $array[0]{"quantity"};
        $sum += $volume;
        if ( $sum >= $maxsum ) {
            return $price;
            last;
        }
    }
}


sub binance_volat {
    my $marginadd = 0.01;
    my $marginadd_1 = 0.01;
    my $marginadd_2 = 0.01;
    my $marginadd_3 = 0.01;

    my $kline_1 = binance_kline("KMD","BTC","15m","3");
    if ( $kline_1 ne "1" ) {
        # marginadd_1 is the oldest
        $marginadd_1 = from_json($kline_1)->[0][2] / from_json($kline_1)->[0][3] - 1;
        $marginadd_2 = from_json($kline_1)->[1][2] / from_json($kline_1)->[1][3] - 1;
        $marginadd_3 = from_json($kline_1)->[2][2] / from_json($kline_1)->[2][3] - 1;
    }
    $marginadd = ($marginadd_1 + $marginadd_2 + $marginadd_3)/3;

    print "volat: ".sprintf("%.3f", $marginadd_1)." ".sprintf("%.3f", $marginadd_2)." ".sprintf("%.3f", $marginadd_3)." / ".sprintf("%.3f", $marginadd)."\n";
    return $marginadd;
}


if ( $api eq "dex_gecko" ) {
    $userpass =  $ENV{'userpass'};
    my $json = read_file("$cwd/mpm.conf.dex");
    $marginsconf = decode_json($json);
    my @stablecoins_usd = ("USDT-BEP20","USDT-PLG20","USDT-AVX20","USDT-KRC20","FDUSD-BEP20","DAI-BEP20","DAI-AVX20","DAI-ERC20","DAI-PLG20","TUSD-BEP20","TUSD-PLG20","USDC-BEP20","USDC-PLG20","USDC-AVX20","USDC-KRC20");
    my @stablecoins_eur = ("EURS-PLG20","AGEUR-PLG20","JEUR-PLG20","EURE-PLG20","EUROE-PLG20");
    my @stablecoins_try = ("TRYB-BEP20","TRYB-AVX20","TRYB-PLG20","JTRY-PLG20");
    #my @stablecoins_other = ("TRYB-BEP20","TRYB-AVX20","TRYB-PLG20","JTRY-PLG20","BIDR-BEP20","JPYC-PLG20","JJPY-PLG20","BRZ-BEP20","QC-QRC20","CADC-PLG20","XSGD-PLG20","JCHF-PLG20","JGBP-PLG20","NZDS-PLG20","JCAD-PLG20","JSGD-PLG20","JCNY-PLG20","JAUD-PLG20","JBRL-PLG20","JBRL-BEP20","JKRW-PLG20","JMXN-PLG20","JSEK-PLG20");
    my $ids = "bitcoin,ethereum,qtum,litecoin,bitcoin-cash,komodo,dogecoin,dash,avalanche-2,binancecoin,polygon-ecosystem-token,fantom,harmony,kucoin-shares,huobi-token,moonbeam,moonriver,zelcash,syscoin,pirate-chain,energy-web-token,digibyte";
    foreach my $coin ( keys %{$marginsconf} ) {
        if ( defined $marginsconf->{$coin}{'geckoid'} ) {
            $ids = $ids.",".$marginsconf->{$coin}{'geckoid'};
        }
    }

    shift @ARGV;
    foreach my $base(@ARGV) {

        my $gecko_price = gecko_latest_price($ids);
        my $freiexchange_price = freiexchange_latest_price();

        my $btcfee = dex_gettradefee("BTC-segwit");
        my $erc20fee = 1;
        my $arb20fee = 1;
        my $qtumfee = 1;
        my $ewtfee = 1;
        my $qrc20fee = 1;
        my $avx20fee = 1;
        my $bep20fee = 1;
        my $plg20fee = 1;
        my $hrc20fee = 1;
        my $krc20fee = 1;
        my $glm20fee = 1;
        my $mvr20fee = 1;
        if ( $gecko_price ne "1" ) {
            $erc20fee = dex_gettradefee("ETH") * from_json($gecko_price)->{"ethereum"}{"usd"};
            $arb20fee = dex_gettradefee("ETH-ARB20") * from_json($gecko_price)->{"ethereum"}{"usd"};
            $ewtfee = dex_gettradefee("EWT") * from_json($gecko_price)->{"energy-web-token"}{"usd"};
            $qtumfee = dex_gettradefee("QTUM") * from_json($gecko_price)->{"qtum"}{"usd"};
            $qrc20fee = dex_gettradefee("QC-QRC20") * from_json($gecko_price)->{"qtum"}{"usd"};
            $avx20fee = dex_gettradefee("AVAX") * from_json($gecko_price)->{"avalanche-2"}{"usd"};
            $bep20fee = dex_gettradefee("BNB") * from_json($gecko_price)->{"binancecoin"}{"usd"};
            $plg20fee = dex_gettradefee("POL") * from_json($gecko_price)->{"polygon-ecosystem-token"}{"usd"};
            $hrc20fee = dex_gettradefee("ONE") * from_json($gecko_price)->{"harmony"}{"usd"};
            $krc20fee = dex_gettradefee("KCS") * from_json($gecko_price)->{"kucoin-shares"}{"usd"};
            $glm20fee = dex_gettradefee("GLMR") * from_json($gecko_price)->{"moonbeam"}{"usd"};
            $mvr20fee = dex_gettradefee("MOVR") * from_json($gecko_price)->{"moonriver"}{"usd"};
        } else {
            my $eth_usd_price = komodolive_latest_price("ETH");
            $erc20fee = dex_gettradefee("ETH") * from_json($eth_usd_price)->{"last_price"};
            $arb20fee = dex_gettradefee("ETH-ARB20") * from_json($eth_usd_price)->{"last_price"};
            my $ewt_usd_price = komodolive_latest_price("EWT");
            $ewtfee = dex_gettradefee("EWT") * from_json($ewt_usd_price)->{"last_price"};
            my $qtum_usd_price = komodolive_latest_price("QTUM");
            $qtumfee = dex_gettradefee("QTUM") * from_json($qtum_usd_price)->{"last_price"};
            $qrc20fee = dex_gettradefee("QC-QRC20") * from_json($qtum_usd_price)->{"last_price"};
            my $avax_usd_price = komodolive_latest_price("AVAX");
            $avx20fee = dex_gettradefee("AVAX") * from_json($avax_usd_price)->{"last_price"};
            my $bnb_usd_price = komodolive_latest_price("BNB");
            $bep20fee = dex_gettradefee("BNB") * from_json($bnb_usd_price)->{"last_price"};
            my $pol_usd_price = komodolive_latest_price("POL");
            $plg20fee = dex_gettradefee("POL") * from_json($pol_usd_price)->{"last_price"};
            my $one_usd_price = komodolive_latest_price("ONE");
            $hrc20fee = dex_gettradefee("ONE") * from_json($one_usd_price)->{"last_price"};
            my $kcs_usd_price = komodolive_latest_price("KCS");
            $krc20fee = dex_gettradefee("KCS") * from_json($kcs_usd_price)->{"last_price"};
            my $glmr_usd_price = komodolive_latest_price("GLMR");
            $glm20fee = dex_gettradefee("GLMR") * from_json($glmr_usd_price)->{"last_price"};
            my $movr_usd_price = komodolive_latest_price("MOVR");
            $mvr20fee = dex_gettradefee("MOVR") * from_json($movr_usd_price)->{"last_price"};
       }

        my $btcusdprice = 0;
        my $ltcusdprice = 0;
        my $dogeusdprice = 0;
        my $dgbusdprice = 0;
        my $ethusdprice = 0;
        if ( $gecko_price ne "1" ) {
            $btcusdprice = from_json($gecko_price)->{"bitcoin"}{"usd"};
            $ltcusdprice = from_json($gecko_price)->{"litecoin"}{"usd"};
            $dogeusdprice = from_json($gecko_price)->{"dogecoin"}{"usd"};
            $dgbusdprice = from_json($gecko_price)->{"digibyte"}{"usd"};
            $ethusdprice = from_json($gecko_price)->{"ethereum"}{"usd"};
        } else {
            my $binance_btcusdprice = binance_latest_price("BTCUSDT");
            if ( $binance_btcusdprice ne "1" ) { $btcusdprice = from_json($binance_btcusdprice)->{"price"}; }
            my $binance_ltcusdprice = binance_latest_price("LTCUSDT");
            if ( $binance_ltcusdprice ne "1" ) { $ltcusdprice = from_json($binance_ltcusdprice)->{"price"}; }
            my $binance_dogeusdprice = binance_latest_price("DOGEUSDT");
            if ( $binance_dogeusdprice ne "1" ) { $dogeusdprice = from_json($binance_dogeusdprice)->{"price"}; }
            my $binance_dgbusdprice = binance_latest_price("DGBUSDT");
            if ( $binance_dgbusdprice ne "1" ) { $dgbusdprice = from_json($binance_dgbusdprice)->{"price"}; }
            my $binance_ethusdprice = binance_latest_price("ETHUSDT");
            if ( $binance_ethusdprice ne "1" ) { $ethusdprice = from_json($binance_ethusdprice)->{"price"}; }
        }
        my $vrscusdprice = 0;
        my $vrsc_price = vrscbridge_latest_price();
        if ( $vrsc_price ne "1" ) {
            $vrscusdprice = from_json($vrsc_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[1]{"reserves"} / from_json($vrsc_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[0]{"reserves"};
        }

        my $base_usd_price = 0;
        my $base_btc_price = 0;
        my $base_4h_change = 0;
        if ( $base eq "KMD" ) {
            my $coinex_price_usd = coinex_latest_price("KMDUSDT");
            if ( $coinex_price_usd ne "1" ) {
                $base_usd_price = from_json($coinex_price_usd)->{"data"}{"ticker"}{"last"};
                $base_btc_price = from_json($coinex_price_usd)->{"data"}{"ticker"}{"last"} / $btcusdprice;
            } else {
                $base_usd_price = 0;
                $base_btc_price = 0;
            }
            if ( $gecko_price ne "1" ) {
                $base_4h_change = abs(from_json($gecko_price)->{"komodo"}{"usd_24h_change"});
            }
#            my $kucoin_price_usd = kucoin_latest_price("KMD-USDT");
#            if ( $kucoin_price_usd ne "1" ) {
#                my $bestbid = $kucoin_price_usd->{"bestBid"};
#                my $bestask = $kucoin_price_usd->{"bestAsk"};
#                if (($bestbid > 0) && ($bestask > 0)) {
#                     $base_usd_price = ( $bestbid + $bestask + $kucoin_price_usd->{"price"} ) / 3;
#                     $base_btc_price = ( $bestbid + $bestask + $kucoin_price_usd->{"price"} ) / 3 / $btcusdprice;
#                } else {
#                     $base_usd_price = 0;
#                     $base_btc_price = 0;
#                }
#            } else {
#                $base_usd_price = 0;
#                $base_btc_price = 0;
#            }

#            if ( $gecko_price ne "1" ) {
#                $base_btc_price = from_json($gecko_price)->{"komodo"}{"btc"};
#                $base_usd_price = from_json($gecko_price)->{"komodo"}{"usd"};
#                $base_4h_change = abs(from_json($gecko_price)->{"komodo"}{"usd_24h_change"});
#            } else {
#                $base_btc_price = 0;
#                $base_usd_price = 0;
#            }
        } elsif ( $base eq "BNB" ) {
            my $binance_price_usd = binance_xxhr_price("BNBUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"lastPrice"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_xxhr_price("BNBBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"lastPrice"}; } else { $base_btc_price = 0; }
            if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
        } elsif ( $base eq "VRSC" ) {
            my $vrscbridge_price_usd = vrscbridge_latest_price();
            if ( $vrscbridge_price_usd ne "1" ) {
                $base_btc_price = from_json($vrscbridge_price_usd)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[1]{"reserves"} / from_json($vrscbridge_price_usd)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[0]{"reserves"} / $btcusdprice;
                $base_usd_price = from_json($vrscbridge_price_usd)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[1]{"reserves"} / from_json($vrscbridge_price_usd)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[0]{"reserves"};
            } else {
                $base_usd_price = 0;
                $base_btc_price = 0;
            }
        } elsif ( ($base eq "ARRR") || ($base eq "vARRR") ) {
            if ( $gecko_price ne "1" ) {
                $base_btc_price = from_json($gecko_price)->{"pirate-chain"}{"btc"};
                $base_usd_price = from_json($gecko_price)->{"pirate-chain"}{"usd"};
                $base_4h_change = abs(from_json($gecko_price)->{"pirate-chain"}{"usd_24h_change"});
            } else {
                $base_btc_price = 0;
                $base_usd_price = 0;
            }
#            my $nonkyc_price_usd = nonkyc_latest_price("ARRR_USDT");
#            if ( $nonkyc_price_usd ne "1" ) {
#                my $bidrate_usd = from_json($nonkyc_price_usd)->{"bid"};
#                my $askrate_usd = from_json($nonkyc_price_usd)->{"ask"};
#                if (($askrate_usd > 0) && ($bidrate_usd > 0)) {
#                    $base_usd_price = ( $askrate_usd + $bidrate_usd + from_json($nonkyc_price_usd)->{"last_price"} ) / 3;
#                } else {
#                    $base_usd_price = 0;
#                }
#            }
#            my $nonkyc_price_btc = nonkyc_latest_price("ARRR_BTC");
#            if ( $nonkyc_price_btc ne "1" ) {
#                my $bidrate_btc = from_json($nonkyc_price_btc)->{"bid"};
#                my $askrate_btc = from_json($nonkyc_price_btc)->{"ask"};
#                if (($askrate_btc > 0) && ($bidrate_btc > 0)) {
#                    $base_btc_price = ( $askrate_btc + $bidrate_btc + from_json($nonkyc_price_btc)->{"last_price"} ) / 3;
#                } else {
#                    $base_btc_price = 0;
#                }
#            }
#            if ( from_json($nonkyc_price_usd)->{"high"} > 0 ) { $base_4h_change = (1 - from_json($nonkyc_price_usd)->{"low"} / from_json($nonkyc_price_usd)->{"high"}) * 100; }
        } elsif ( $base eq "SYS-segwit" ) {
            my $binance_price_usd = binance_xxhr_price("SYSUSDT");
            if ( $binance_price_usd ne "1" ) {
                $base_usd_price = from_json($binance_price_usd)->{"lastPrice"};
                $base_btc_price = from_json($binance_price_usd)->{"lastPrice"} / $btcusdprice;
                if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
            } else {
                $base_usd_price = 0;
                $base_btc_price = 0;
            }
        } elsif ( $base eq "FLUX" ) {
            my $binance_price_usd = binance_xxhr_price("FLUXUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"lastPrice"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_xxhr_price("FLUXBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"lastPrice"}; } else { $base_btc_price = 0; }
            if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
        } elsif ( $base eq "LTC-segwit" ) {
            my $binance_price_usd = binance_xxhr_price("LTCUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"lastPrice"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_xxhr_price("LTCBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"lastPrice"}; } else { $base_btc_price = 0; }
            if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
        } elsif ( $base eq "BCH" ) {
            my $binance_price_usd = binance_xxhr_price("BCHUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"lastPrice"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_xxhr_price("BCHBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"lastPrice"}; } else { $base_btc_price = 0; }
            if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
        } elsif ( $base eq "DASH" ) {
            my $binance_price_usd = binance_xxhr_price("DASHUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"lastPrice"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_xxhr_price("DASHBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"lastPrice"}; } else { $base_btc_price = 0; }
            if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
        } elsif ( $base eq "DGB-segwit" ) {
            my $binance_price_usd = binance_xxhr_price("DGBUSDT");
            if ( $binance_price_usd ne "1" ) {
                $base_usd_price = from_json($binance_price_usd)->{"lastPrice"};
                $base_btc_price = from_json($binance_price_usd)->{"lastPrice"} / $btcusdprice;
                if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
            } else {
                $base_usd_price = 0;
                $base_btc_price = 0;
            }
        } elsif ( $base eq "POL" ) {
            my $binance_price_usd = binance_xxhr_price("POLUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"lastPrice"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_xxhr_price("POLBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"lastPrice"}; } else { $base_btc_price = 0; }
            if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
        } elsif ( $base eq "ZEC" ) {
            my $binance_price_usd = binance_xxhr_price("ZECUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"lastPrice"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_xxhr_price("ZECBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"lastPrice"}; } else { $base_btc_price = 0; }
            if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
        } elsif ( $base eq "RVN" ) {
            my $binance_price_usd = binance_xxhr_price("RVNUSDT");
            if ( $binance_price_usd ne "1" ) {
                $base_usd_price = from_json($binance_price_usd)->{"lastPrice"};
                $base_btc_price = from_json($binance_price_usd)->{"lastPrice"} / $btcusdprice;
                if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
            } else {
                $base_usd_price = 0;
                $base_btc_price = 0;
            }
        } elsif ( $base eq "QTUM" ) {
            my $binance_price_usd = binance_xxhr_price("QTUMUSDT");
            if ( $binance_price_usd ne "1" ) {
                $base_usd_price = from_json($binance_price_usd)->{"lastPrice"};
                $base_btc_price = from_json($binance_price_usd)->{"lastPrice"} / $btcusdprice;
                if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
            } else {
                $base_usd_price = 0;
                $base_btc_price = 0;
            }
        } elsif ( ($base eq "DOGE") || ($base eq "DOGE-BEP20") ) {
            my $binance_price_usd = binance_xxhr_price("DOGEUSDT");
            if ( $binance_price_usd ne "1" ) {
                $base_usd_price = from_json($binance_price_usd)->{"lastPrice"};
                $base_btc_price = from_json($binance_price_usd)->{"lastPrice"} / $btcusdprice;
                if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
            } else {
                $base_usd_price = 0;
                $base_btc_price = 0;
            }
        } elsif ( ($base eq "FIRO") || ($base eq "FIRO-BEP20") ) {
            my $coinex_price_usd = coinex_latest_price("FIROUSDT");
            if ( $coinex_price_usd ne "1" ) {
                $base_usd_price = from_json($coinex_price_usd)->{"data"}{"ticker"}{"last"};
                $base_btc_price = from_json($coinex_price_usd)->{"data"}{"ticker"}{"last"} / $btcusdprice;
            } else {
                $base_usd_price = 0;
                $base_btc_price = 0;
            }
            if ( $gecko_price ne "1" ) {
                $base_4h_change = abs(from_json($gecko_price)->{"zcoin"}{"usd_24h_change"});
            }
        } elsif ( ($base eq "ETH") || ($base eq "ETH-BEP20") || ($base eq "ETH-PLG20") ) {
            my $binance_price_usd = binance_xxhr_price("ETHUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"lastPrice"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_xxhr_price("ETHBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"lastPrice"}; } else { $base_btc_price = 0; }
            if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
        } elsif ( ($base eq "BTC") || ($base eq "BTC-BEP20") || ($base eq "BTC-segwit") || ($base eq "WBTC-PLG20") || ($base eq "TBTC-PLG20") ) {
            my $binance_price_usd = binance_xxhr_price("BTCUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"lastPrice"}; } else { $base_usd_price = 0; }
            $base_btc_price = 1;
            if ( from_json($binance_price_usd)->{"highPrice"} > 0 ) { $base_4h_change = (1 - from_json($binance_price_usd)->{"lowPrice"} / from_json($binance_price_usd)->{"highPrice"}) * 100; }
        } elsif ( $base ~~ @stablecoins_eur ) {
            my $chainlink_price = chainlink_latest_price_eth("0xb49f677943bc038e9857d61e7d053caa2c1734c1");
            if ( $chainlink_price ne "1" ) { $base_usd_price = hex(from_json($chainlink_price)->{"result"}) / 100000000; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_xxhr_price("BTCEUR");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = 1 / from_json($binance_price_btc)->{"lastPrice"}; } else { $base_btc_price = 0; }
        } elsif ( $base ~~ @stablecoins_try ) {
            my $chainlink_price = chainlink_latest_price_eth("0xb09fc5fd3f11cf9eb5e1c5dba43114e3c9f477b5");
            if ( $chainlink_price ne "1" ) { $base_usd_price = hex(from_json($chainlink_price)->{"result"}) / 100000000; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_xxhr_price("BTCTRY");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = 1 / from_json($binance_price_btc)->{"lastPrice"}; } else { $base_btc_price = 0; }
        } elsif ( $base ~~ @stablecoins_usd ) {
            $base_usd_price = 1;
            my $binance_price_btc = binance_xxhr_price("BTCUSDT");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = 1 / from_json($binance_price_btc)->{"lastPrice"}; } else { $base_btc_price = 0; }
        }

        if ( ($base_usd_price > 0) && ($base_btc_price > 0) ) {

             my $base_mintradevol = dex_getmintradevol($base);
             my $base_balance = dex_getbalance($base);

            foreach my $coin ( sort (keys %{$marginsconf}) ) {
                if ($base eq $coin) { next; }
                my $geckoid = $marginsconf->{$coin}{'geckoid'};
                my $type = $marginsconf->{$coin}{'type'};
                if ( !defined $type ) { $type = "utxo"; }

                my $binance_usd_symbol = $marginsconf->{$coin}{'binance_usd_symbol'};
                my $binance_usdinv_symbol = $marginsconf->{$coin}{'binance_usdinv_symbol'};
                my $binance_btc_symbol = $marginsconf->{$coin}{'binance_btc_symbol'};
                my $binance_info_symbol = $marginsconf->{$coin}{'binance_info_symbol'};
                my $safetrade_btc_symbol = $marginsconf->{$coin}{'safetrade_btc_symbol'};
                my $freiexchange_btc_symbol = $marginsconf->{$coin}{'freiexchange_btc_symbol'};
                my $freiexchange_ltc_symbol = $marginsconf->{$coin}{'freiexchange_ltc_symbol'};
                my $bittrex_btc_symbol = $marginsconf->{$coin}{'bittrex_btc_symbol'};
                my $bittrex_usd_symbol = $marginsconf->{$coin}{'bittrex_usd_symbol'};
                my $coinex_usd_symbol = $marginsconf->{$coin}{'coinex_usd_symbol'};
                my $coinex_btc_symbol = $marginsconf->{$coin}{'coinex_btc_symbol'};
                my $coinex_info_symbol = $marginsconf->{$coin}{'coinex_info_symbol'};
                my $kucoin_usd_symbol = $marginsconf->{$coin}{'kucoin_usd_symbol'};
                my $ogre_btc_symbol = $marginsconf->{$coin}{'ogre_btc_symbol'};
                my $ogre_usd_symbol = $marginsconf->{$coin}{'ogre_usd_symbol'};
                my $ogre_ltc_symbol = $marginsconf->{$coin}{'ogre_ltc_symbol'};
                my $hitbtc_btc_symbol = $marginsconf->{$coin}{'hitbtc_btc_symbol'};
                my $bithumb_usd_symbol = $marginsconf->{$coin}{'bithumb_usd_symbol'};
                my $exbitron_usd_symbol = $marginsconf->{$coin}{'exbitron_usd_symbol'};
                my $nestex_usd_symbol = $marginsconf->{$coin}{'nestex_usd_symbol'};
                my $nonkyc_usd_symbol = $marginsconf->{$coin}{'nonkyc_usd_symbol'};
                my $nonkyc_info_symbol = $marginsconf->{$coin}{'nonkyc_info_symbol'};
                my $bittrex_info_symbol = $marginsconf->{$coin}{'bittrex_info_symbol'};
                my $mexc_usd_symbol = $marginsconf->{$coin}{'mexc_usd_symbol'};
                my $chipsbridge_vrsc_symbol = $marginsconf->{$coin}{'chipsbridge_vrsc_symbol'};
                my $vrscbridge_usd_symbol = $marginsconf->{$coin}{'vrscbridge_usd_symbol'};
                my $vdexbridge_usd_symbol = $marginsconf->{$coin}{'vdexbridge_usd_symbol'};
                my $varrrbridge_btc_symbol = $marginsconf->{$coin}{'varrrbridge_btc_symbol'};
                my $paprika_id = $marginsconf->{$coin}{'paprika_id'};
                my $sane_price = $marginsconf->{$coin}{'sane_price'};
                my $komodolive_usd_symbol = $marginsconf->{$coin}{'komodolive_usd_symbol'};
                my $dextrade_usd_symbol = $marginsconf->{$coin}{'dextrade_usd_symbol'};
                my $usd_stablecoin = $marginsconf->{$coin}{'usd_stablecoin'};
                my $chainlink_usd_eth = $marginsconf->{$coin}{'chainlink_usd_eth'};
                my $chainlink_usd_bep = $marginsconf->{$coin}{'chainlink_usd_bep'};
                my $chainlink_usd_arb = $marginsconf->{$coin}{'chainlink_usd_arb'};
                my $price = 0;
                my $change = 0;
                my $coinusdprice = 0;

                if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                    my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                    if (!defined $geckousdprice) {
                        print "============== geckoid: $geckoid undefined\n";
                    } else {
                        $price = $geckousdprice / $base_usd_price;
                    }
                    $coinusdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                    if ( defined from_json($gecko_price)->{$geckoid}{"usd_24h_change"} ) { $change = abs(from_json($gecko_price)->{$geckoid}{"usd_24h_change"}); }
                    #if ( (($coin ~~ @stablecoins_usd) || ($coin ~~ @stablecoins_eur) || ($coin ~~ @stablecoins_other)) && (defined from_json($gecko_price)->{$geckoid}{"btc_24h_change"}) ) { $change = abs(from_json($gecko_price)->{$geckoid}{"btc_24h_change"}); }
                }

                if ( defined $binance_usd_symbol ) {
                    my $binance_price = binance_xxhr_price($binance_usd_symbol);
                    if ( $binance_price ne "1" ) {
                        $price = from_json($binance_price)->{"lastPrice"} / $base_usd_price;
                        $coinusdprice = from_json($binance_price)->{"lastPrice"};
                        if ( from_json($binance_price)->{"highPrice"} > 0 ) { $change = (1 - from_json($binance_price)->{"lowPrice"} / from_json($binance_price)->{"highPrice"}) * 100; }
                        if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                            my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                            my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                            if ($diff > 2) {
                                print "============== $coin binance_usd ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 2\n";
                            }
                        }
                    }
                } elsif ( defined $binance_usdinv_symbol ) {
                    my $binance_price = binance_xxhr_price($binance_usdinv_symbol);
                    if ( $binance_price ne "1" ) {
                        $coinusdprice = 1 / from_json($binance_price)->{"lastPrice"};
                        $price = $coinusdprice / $base_usd_price;
                        if ( from_json($binance_price)->{"highPrice"} > 0 ) { $change = (1 - from_json($binance_price)->{"lowPrice"} / from_json($binance_price)->{"highPrice"}) * 100; }
                    }
                } elsif ( defined $binance_btc_symbol ) {
                    my $binance_price = binance_xxhr_price($binance_btc_symbol);
                    if ( $binance_price ne "1" ) {
                        $price = from_json($binance_price)->{"lastPrice"} / $base_btc_price;
                        $coinusdprice = from_json($binance_price)->{"lastPrice"} * $btcusdprice;
                        if ( from_json($binance_price)->{"highPrice"} > 0 ) { $change = (1 - from_json($binance_price)->{"lowPrice"} / from_json($binance_price)->{"highPrice"}) * 100; }
                    }
                } elsif ( defined $dextrade_usd_symbol ) {
                    my $dextrade_price = dextrade_latest_price($dextrade_usd_symbol);
                    if ( $dextrade_price ne "1" ) {
                        $price = from_json($dextrade_price)->{"data"}{"last"} / $base_usd_price;
                        $coinusdprice = from_json($dextrade_price)->{"data"}{"last"};
                        if ( from_json($dextrade_price)->{"data"}{"high"} > 0 ) { $change = (1 - from_json($dextrade_price)->{"data"}{"low"} / from_json($dextrade_price)->{"data"}{"high"}) * 100; }
                        if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                            my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                            my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                            if ($diff > 5) {
                                print "============== $coin dextrade_usd ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 5\n";
                            }
                        }
                    }
                } elsif ( defined $safetrade_btc_symbol ) {
                    my $safetrade_price = safetrade_latest_price($safetrade_btc_symbol);
                    if ( $safetrade_price ne "1" ) {
                        my $buy = from_json($safetrade_price)->{"ticker"}{"buy"};
                        my $sell = from_json($safetrade_price)->{"ticker"}{"sell"};
                        if (($sell > 0) && ($buy > 0)) {
                            $price = ( $buy + $sell + from_json($safetrade_price)->{"ticker"}{"last"} ) / 3 / $base_btc_price;
                            $coinusdprice = ( $buy + $sell + from_json($safetrade_price)->{"ticker"}{"last"} ) / 3 * $btcusdprice;
                        } else {
                            $price = from_json($safetrade_price)->{"ticker"}{"last"} / $base_btc_price;
                            $coinusdprice = from_json($safetrade_price)->{"ticker"}{"last"} * $btcusdprice;
                            print "========= wrong price for $coin  bid $buy  ask $sell\n";
                        }
                        if ( from_json($safetrade_price)->{"ticker"}{"high"} > 0 ) { $change = (1 - from_json($safetrade_price)->{"ticker"}{"low"} / from_json($safetrade_price)->{"ticker"}{"high"}) * 100; }
                    }
                } elsif ( defined $exbitron_usd_symbol ) {
                    my $exbitron_price = exbitron_latest_price($exbitron_usd_symbol);
                    if ( $exbitron_price ne "1" ) {
                        $price = ( from_json($exbitron_price)->{"data"}{"market"}{"marketDynamics"}{"lastPrice"} + from_json($exbitron_price)->{"data"}{"market"}{"highestBid"} + from_json($exbitron_price)->{"data"}{"market"}{"lowestAsk"} ) / 3 / $base_usd_price;
                        $coinusdprice = ( from_json($exbitron_price)->{"data"}{"market"}{"marketDynamics"}{"lastPrice"} + from_json($exbitron_price)->{"data"}{"market"}{"highestBid"} + from_json($exbitron_price)->{"data"}{"market"}{"lowestAsk"} ) / 3;
                        if ( from_json($exbitron_price)->{"data"}{"market"}{"marketDynamics"}{"highPrice"} > 0 ) { $change = (1 - from_json($exbitron_price)->{"data"}{"market"}{"marketDynamics"}{"lowPrice"} / from_json($exbitron_price)->{"data"}{"market"}{"marketDynamics"}{"highPrice"}) * 100; }
                    }
                } elsif ( defined $nestex_usd_symbol ) {
                    my $nestex_price = nestex_latest_price($nestex_usd_symbol);
                    if ( $nestex_price ne "1" ) {
                        $price = ( from_json($nestex_price)->{"last_price"} + from_json($nestex_price)->{"bid"} + from_json($nestex_price)->{"ask"} ) / 3 / $base_usd_price;
                        $coinusdprice = ( from_json($nestex_price)->{"last_price"} + from_json($nestex_price)->{"bid"} + from_json($nestex_price)->{"ask"} ) / 3;
                        if ( from_json($nestex_price)->{"high"} > 0 ) { $change = (1 - from_json($nestex_price)->{"low"} / from_json($nestex_price)->{"high"}) * 100; }
                    }
                } elsif ( defined $nonkyc_usd_symbol ) {
                    my $nonkyc_price = nonkyc_latest_price($nonkyc_usd_symbol);
                    if ( $nonkyc_price ne "1" ) {
                        my $bidrate = from_json($nonkyc_price)->{"bid"};
                        my $askrate = from_json($nonkyc_price)->{"ask"};
                        if (($askrate > 0) && ($bidrate > 0)) {
                            $price = ( $askrate + $bidrate + from_json($nonkyc_price)->{"last_price"} ) / 3 / $base_usd_price;
                            $coinusdprice = ( $askrate + $bidrate + from_json($nonkyc_price)->{"last_price"} ) / 3;
                            if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                                my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                                my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                                if ($diff > 4) {
                                    print "============== $coin nonkyc_usd ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 4\n";
                                }
                            }
                        } else {
                            print "========= wrong price for $coin  bid $bidrate  ask $askrate\n";
                        }
                        if ( from_json($nonkyc_price)->{"high"} > 0 ) { $change = (1 - from_json($nonkyc_price)->{"low"} / from_json($nonkyc_price)->{"high"}) * 100; }
                    }
                } elsif ( defined $mexc_usd_symbol ) {
                    my $mexc_price = mexc_latest_price($mexc_usd_symbol);
                    if ( $mexc_price ne "1" ) {
                        my $bidprice = from_json($mexc_price)->{"bidPrice"};
                        my $askprice = from_json($mexc_price)->{"askPrice"};
                        if (($bidprice > 0) && ($askprice > 0)) {
                            $price = ( $bidprice + $askprice + from_json($mexc_price)->{"lastPrice"} ) / 3 / $base_usd_price;
                            $coinusdprice = ( $bidprice + $askprice + from_json($mexc_price)->{"lastPrice"} ) / 3;
                            if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                                my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                                my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                                if ($diff > 4) {
                                    print "============== $coin mexc_usd ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 4\n";
                                }
                            }
                        } else {
                            print "========= wrong price for $coin  bid $bidprice  ask $askprice\n";
                        }
                        if ( from_json($mexc_price)->{"highPrice"} > 0 ) { $change = (1 - from_json($mexc_price)->{"lowPrice"} / from_json($mexc_price)->{"highPrice"}) * 100; }
                    }
                } elsif ( defined $komodolive_usd_symbol ) {
                    my $komodolive_price = komodolive_latest_price($komodolive_usd_symbol);
                    if ( $komodolive_price ne "1" ) {
                        my $now = time();
                        my $last_updated = from_json($komodolive_price)->{"last_updated_timestamp"};
                        my $timediff = $now - $last_updated;
                        if ( $timediff < 259200 ) {
                            $coinusdprice = from_json($komodolive_price)->{"last_price"};
                            $price = $coinusdprice / $base_usd_price;
                            $change = abs(from_json($komodolive_price)->{"change_24h"});
                        } else {
                            print "================ price too old ================ now: $now, last_updated: $last_updated, diff: $timediff ================\n";
                        }
                    }
                } elsif ( defined $chipsbridge_vrsc_symbol ) {
                    my $chipsbridge_price = chipsbridge_latest_price();
                    if ( $chipsbridge_price ne "1" ) {
                        $price = from_json($chipsbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[0]{"reserves"} / from_json($chipsbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[1]{"reserves"} * $vrscusdprice / $base_usd_price;
                        $coinusdprice = from_json($chipsbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[0]{"reserves"} / from_json($chipsbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[1]{"reserves"} * $vrscusdprice;
                        if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                            my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                            my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                            if ($diff > 5) {
                                print "============== $coin vrsc_bridge ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 5\n";
                            }
                        }
                    }
                } elsif ( defined $vrscbridge_usd_symbol ) {
                    my $vrscbridge_price = vrscbridge_latest_price();
                    if ( $vrscbridge_price ne "1" ) {
                        $price = from_json($vrscbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[1]{"reserves"} / from_json($vrscbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[0]{"reserves"} / $base_usd_price;
                        $coinusdprice = from_json($vrscbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[1]{"reserves"} / from_json($vrscbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[0]{"reserves"};
                        if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                            my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                            my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                            if ($diff > 5) {
                                print "============== $coin vrsc_bridge ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 5\n";
                            }
                        }
                    }
                } elsif ( defined $varrrbridge_btc_symbol ) {
                    my $varrrbridge_price = varrrbridge_latest_price();
                    if ( $varrrbridge_price ne "1" ) {
                        $price = from_json($varrrbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[3]{"reserves"} / from_json($varrrbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[1]{"reserves"} / $base_btc_price;
                        $coinusdprice = from_json($varrrbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[3]{"reserves"} / from_json($varrrbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[1]{"reserves"} * $btcusdprice;
                        if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                            my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                            my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                            if ($diff > 5) {
                                print "============== $coin vrsc_bridge ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 5\n";
                            }
                        }
                    }
                } elsif ( defined $vdexbridge_usd_symbol ) {
                    my $vdexbridge_price = vdexbridge_latest_price();
                    if ( $vdexbridge_price ne "1" ) {
                        $price = from_json($vdexbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[3]{"reserves"} / from_json($vdexbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[1]{"reserves"} / $base_usd_price;
                        $coinusdprice = from_json($vdexbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[3]{"reserves"} / from_json($vdexbridge_price)->{"result"}[0]{"currencystate"}{"reservecurrencies"}[1]{"reserves"};
                        if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                            my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                            my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                            if ($diff > 5) {
                                print "============== $coin vrsc_bridge ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 5\n";
                            }
                        }
                    }
                } elsif ( (defined $freiexchange_btc_symbol) && ($freiexchange_price ne "1") ) {
                    $price = ( from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"highestBuy"} + from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"lowestSell"} + from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"last"} ) / 3 / $base_btc_price;
                    $coinusdprice = ( from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"highestBuy"} + from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"lowestSell"} + from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"last"} ) / 3 * $btcusdprice;
                    $change = abs(from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"percent_change_24h"});
                    if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                        my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                        my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                        if ($diff > 16) {
                            print "============== $coin frei_btc ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 16\n";
                        }
                    }
                } elsif ( (defined $freiexchange_ltc_symbol) && ($freiexchange_price ne "1") ) {
                    $price = ( from_json($freiexchange_price)->{$freiexchange_ltc_symbol}->[0]{"highestBuy"} + from_json($freiexchange_price)->{$freiexchange_ltc_symbol}->[0]{"lowestSell"} + from_json($freiexchange_price)->{$freiexchange_ltc_symbol}->[0]{"last"} ) / 3 * $ltcusdprice / $base_usd_price;
                    $coinusdprice = ( from_json($freiexchange_price)->{$freiexchange_ltc_symbol}->[0]{"highestBuy"} + from_json($freiexchange_price)->{$freiexchange_ltc_symbol}->[0]{"lowestSell"} + from_json($freiexchange_price)->{$freiexchange_ltc_symbol}->[0]{"last"} ) / 3 * $ltcusdprice;
                    $change = abs(from_json($freiexchange_price)->{$freiexchange_ltc_symbol}->[0]{"percent_change_24h"});
                    if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                        my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                        my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                        if ($diff > 16) {
                            print "============== $coin frei_ltc ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 16\n";
                        }
                    }
                } elsif ( defined $usd_stablecoin ) {
                    $coinusdprice = 1;
                    $price = $coinusdprice / $base_usd_price;
                    if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                        my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                        my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                        if ($diff > 1) {
                            print "============== $coin usd_stablecoin ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 1\n";
                        }
                    }
                } elsif ( defined $chainlink_usd_eth ) {
                    my $chainlink_price = chainlink_latest_price_eth($chainlink_usd_eth);
                    if ( $chainlink_price ne "1" ) {
                        $coinusdprice = hex(from_json($chainlink_price)->{"result"}) / 100000000;
                        $price = $coinusdprice / $base_usd_price;
                        if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                            my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                            my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                            if ($diff > 2) {
                                print "============== $coin chainlink ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 2\n";
                            }
                        }
                    }
                } elsif ( defined $chainlink_usd_bep ) {
                    my $chainlink_price = chainlink_latest_price_bep($chainlink_usd_bep);
                    if ( $chainlink_price ne "1" ) {
                        $coinusdprice = hex(from_json($chainlink_price)->{"result"}) / 100000000;
                        $price = $coinusdprice / $base_usd_price;
                        if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                            my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                            my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                            if ($diff > 2) {
                                print "============== $coin chainlink ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 2\n";
                            }
                        }
                    }
                } elsif ( defined $chainlink_usd_arb ) {
                    my $chainlink_price = chainlink_latest_price_arb($chainlink_usd_arb);
                    if ( $chainlink_price ne "1" ) {
                        $coinusdprice = hex(from_json($chainlink_price)->{"result"}) / 100000000;
                        $price = $coinusdprice / $base_usd_price;
                        if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                            my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                            my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                            if ($diff > 2) {
                                print "============== $coin chainlink ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 2\n";
                            }
                        }
                    }
                } elsif ( defined $paprika_id ) {
                    my $paprika_price = paprika_ticker($paprika_id);
                    if ( $paprika_price ne "1" ) {
                        $price = from_json($paprika_price)->{"quotes"}{"USD"}{"price"} / $base_usd_price;
                        $coinusdprice = from_json($paprika_price)->{"quotes"}{"USD"}{"price"};
                        $change = abs(from_json($paprika_price)->{"quotes"}{"USD"}{"percent_change_24h"});
                        if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                            my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                            my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                            if ($diff > 5) {
                                print "============== $coin paprika ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 5\n";
                            }
                        }
                    }
                } elsif ( defined $coinex_usd_symbol ) {
                    my $coinex_price = coinex_latest_price($coinex_usd_symbol);
                    if ( $coinex_price ne "1" ) {
                        my $sell = from_json($coinex_price)->{"data"}{"ticker"}{"sell"};
                        my $buy = from_json($coinex_price)->{"data"}{"ticker"}{"buy"};
                        if (($sell > 0) && ($buy > 0)) {
                            $price = ( $sell + $buy + from_json($coinex_price)->{"data"}{"ticker"}{"last"} ) / 3 / $base_usd_price;
                            $coinusdprice = ( $sell + $buy + from_json($coinex_price)->{"data"}{"ticker"}{"last"} ) / 3;
                            if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                                my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                                my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                                if ($diff > 3) {
                                    print "============== $coin coinex_usd ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 3\n";
                                }
                            }
                        } else {
                            print "========= wrong price for $coin  bid $buy  ask $sell\n";
                        }
                        if ( from_json($coinex_price)->{"data"}{"ticker"}{"high"} > 0 ) { $change = (1 - from_json($coinex_price)->{"data"}{"ticker"}{"low"} / from_json($coinex_price)->{"data"}{"ticker"}{"high"}) * 100;}
                    }
                } elsif ( defined $coinex_btc_symbol ) {
                    my $coinex_price = coinex_latest_price($coinex_btc_symbol);
                    if ( $coinex_price ne "1" ) {
                        my $sell = from_json($coinex_price)->{"data"}{"ticker"}{"sell"};
                        my $buy = from_json($coinex_price)->{"data"}{"ticker"}{"buy"};
                        if (($sell > 0) && ($buy > 0)) {
                            $price = ( $sell + $buy + from_json($coinex_price)->{"data"}{"ticker"}{"last"} ) / 3 / $base_btc_price;
                            $coinusdprice = ( $sell + $buy + from_json($coinex_price)->{"data"}{"ticker"}{"last"} ) / 3 * $btcusdprice;
                        } else {
                            print "========= wrong price for $coin  bid $buy  ask $sell\n";
                        }
                        if ( from_json($coinex_price)->{"data"}{"ticker"}{"high"} > 0 ) { $change = (1 - from_json($coinex_price)->{"data"}{"ticker"}{"low"} / from_json($coinex_price)->{"data"}{"ticker"}{"high"}) * 100;}
                    }
                } elsif ( defined $kucoin_usd_symbol ) {
                    my $kucoin_price = kucoin_latest_price($kucoin_usd_symbol);
                    if ( $kucoin_price ne "1" ) {
                        my $bestbid = $kucoin_price->{"bestBid"};
                        my $bestask = $kucoin_price->{"bestAsk"};
                        if (($bestbid > 0) && ($bestask > 0)) {
                            $price = ( $bestbid + $bestask + $kucoin_price->{"price"} ) / 3 / $base_usd_price;
                            $coinusdprice = ( $bestbid + $bestask + $kucoin_price->{"price"} ) / 3;
                            if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                                my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                                my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                                if ($diff > 3) {
                                    print "============== $coin kucoin_usd ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 3\n";
                                }
                            }
                        } else {
                            print "========= wrong price for $coin  bid $bestbid  ask $bestask\n";
                        }
                    }
                } elsif ( defined $hitbtc_btc_symbol ) {
                    my $hitbtc_price = hitbtc_latest_price($hitbtc_btc_symbol);
                    if ( $hitbtc_price ne "1" ) {
                        $price = ( from_json($hitbtc_price)->{"ask"} + from_json($hitbtc_price)->{"bid"} + from_json($hitbtc_price)->{"last"} ) / 3 / $base_btc_price;
                        $coinusdprice = ( from_json($hitbtc_price)->{"ask"} + from_json($hitbtc_price)->{"bid"} + from_json($hitbtc_price)->{"last"} ) / 3 * $btcusdprice;
                        $change = (1 - from_json($hitbtc_price)->{"low"} / from_json($hitbtc_price)->{"high"}) * 100;
                    }
                } elsif ( defined $ogre_ltc_symbol ) {
                    my $ogre_price = ogre_latest_price($ogre_ltc_symbol);
                    if ( $ogre_price ne "1" ) {
                        my $bestask = from_json($ogre_price)->{"ask"};
                        my $bestbid = from_json($ogre_price)->{"bid"};
                        if (($bestbid > 0) && ($bestask > 0)) {
                            $price = ( $bestbid + $bestask + from_json($ogre_price)->{"price"} ) / 3 * $ltcusdprice / $base_usd_price;
                            $coinusdprice = ( $bestbid + $bestask + from_json($ogre_price)->{"price"} ) / 3 * $ltcusdprice;
                            if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                                my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                                my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                                if ($diff > 4) {
                                    print "============== $coin ogre_ltc ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 4\n";
                                }
                            }
                        } else {
                            print "========= wrong price for $coin  bid $bestbid  ask $bestask\n";
                        }
                        if ( from_json($ogre_price)->{"high"} > 0 ) {$change = (1 - from_json($ogre_price)->{"low"} / from_json($ogre_price)->{"high"}) * 100;}
                    }
                } elsif ( defined $ogre_btc_symbol ) {
                    my $ogre_price = ogre_latest_price($ogre_btc_symbol);
                    if ( $ogre_price ne "1" ) {
                        my $bestask = from_json($ogre_price)->{"ask"};
                        my $bestbid = from_json($ogre_price)->{"bid"};
                        if (($bestbid > 0) && ($bestask > 0)) {
                            $price = ( $bestbid + $bestask + from_json($ogre_price)->{"price"} ) / 3 / $base_btc_price;
                            $coinusdprice = ( $bestbid + $bestask + from_json($ogre_price)->{"price"} ) / 3 * $btcusdprice;
                            if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                                my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                                my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                                if ($diff > 4) {
                                    print "============== $coin ogre_btc ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 4\n";
                                }
                            }
                        } else {
                            print "========= wrong price for $coin  bid $bestbid  ask $bestask\n";
                        }
                        if ( from_json($ogre_price)->{"high"} > 0 ) {$change = (1 - from_json($ogre_price)->{"low"} / from_json($ogre_price)->{"high"}) * 100;}
                    }
                } elsif ( defined $ogre_usd_symbol ) {
                    my $ogre_price = ogre_latest_price($ogre_usd_symbol);
                    if ( $ogre_price ne "1" ) {
                        my $bestask = from_json($ogre_price)->{"ask"};
                        my $bestbid = from_json($ogre_price)->{"bid"};
                        if (($bestbid > 0) && ($bestask > 0)) {
                            $price = ( $bestbid + $bestask + from_json($ogre_price)->{"price"} ) / 3 / $base_usd_price;
                            $coinusdprice = ( $bestbid + $bestask + from_json($ogre_price)->{"price"} ) / 3;
                            if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                                my $geckousdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                                my $diff = sprintf("%.1f",abs((($coinusdprice - $geckousdprice) / $geckousdprice) * 100));
                                if ($diff > 4) {
                                    print "============== $coin ogre_usd ".sprintf("%.8f",$coinusdprice).", gecko ".sprintf("%.8f",$geckousdprice).", diff $diff > 4\n";
                                }
                            }
                        } else {
                            print "========= wrong price for $coin  bid $bestbid  ask $bestask\n";
                        }
                        if ( from_json($ogre_price)->{"high"} > 0 ) {$change = (1 - from_json($ogre_price)->{"low"} / from_json($ogre_price)->{"high"}) * 100;}
                    }
                } elsif ( defined $bithumb_usd_symbol ) {
                    my $bithumb_price = bithumb_latest_price($bithumb_usd_symbol);
                    if ( $bithumb_price ne "1" ) {
                        $price = from_json($bithumb_price)->{"data"}[0]{"c"} / $base_usd_price;
                        $coinusdprice = from_json($bithumb_price)->{"data"}[0]{"c"};
                        $change = (1 - from_json($bithumb_price)->{"data"}[0]{"l"} / from_json($bithumb_price)->{"data"}[0]{"h"}) * 100;
                    }
                }

                my $marginadd = 0;
                if ( (($base eq "KMD") && ($coin eq "KMD-BEP20")) || (($base eq "FIRO") && ($coin eq "FIRO-BEP20")) || (($base eq "DOGE") && ($coin eq "DOGE-BEP20")) || (($base eq "FLUX") && ($coin eq "FLUX-BEP20")) ) {
                    $price = 1;
                } elsif ( (defined $binance_usd_symbol) || (defined $binance_btc_symbol) || (defined $usd_stablecoin) || (defined $chainlink_usd_bep) || (defined $chainlink_usd_eth) || (defined $kucoin_usd_symbol) || (defined $coinex_usd_symbol) ) {
                    $marginadd = max($change,$base_4h_change)/100/5;
                } else {
                    $marginadd = max($change,$base_4h_change)/100/4;
                }
                #print "====== $coin change: $change, $base base_4h_change: $base_4h_change, marginadd: $marginadd\n";

                my $bid = undef;
                my $ask = undef;
                my $askmargin = 0;
                my $bidmargin = 0;
                my $high = 0;
                my $low = 0;
                if ( defined $marginsconf->{$coin}{'askmargin'} ) {
                    $askmargin = $marginsconf->{$coin}{'askmargin'} + $marginadd;
                    if ( ($base eq "KMD") || ($coin eq "KMD") || ($coin eq "KMD-BEP20") ) { $askmargin = $askmargin * 0.95; }
                    $high = $price + $price * $askmargin;
                    $high = sprintf("%.10f", $high);
                    $ask = sprintf("%.10f", $price + $price * $askmargin);
                }
                if ( defined $marginsconf->{$coin}{'bidmargin'} ) {
                    $bidmargin = $marginsconf->{$coin}{'bidmargin'} + $marginadd;
                    if ( ($base eq "KMD") || ($coin eq "KMD") || ($coin eq "KMD-BEP20") ) { $bidmargin = $bidmargin * 0.95; }
                    if ( $bidmargin > 0.99 ) { $bidmargin = 0.99; }
                    $low = $price - $price * $bidmargin;
                    $low = sprintf("%.10f", $low);
                    if ($price ne "0") {$bid = sprintf("%.10f", 1 / ($price - $price * $bidmargin));}
                }
                if ((defined $marginsconf->{$coin}{'askmargin'}) && (defined $marginsconf->{$coin}{'bidmargin'}) && (($high - $low < 0.0000000005) || ($low < 0.0000000110))) {
                    #print "======== kaputtpair $coin/$base  bid $low  ask $high\n";
                    $price = 0;
                }

                my $minaskvolume_btc = undef;
                my $minbidvolume_btc = undef;
                my $minaskvolume_eth = undef;
                my $minbidvolume_eth = undef;
                my $maxbidvolume = undef;
                my $minbidvolume = undef;
                my $maxaskvolume = undef;
                my $minaskvolume = undef;
               if ($coinusdprice > 0) {
                my $maxbidvolume_usd = $marginsconf->{$coin}{'maxbidvolume'};
                if ( defined $maxbidvolume_usd ) { $maxbidvolume = $maxbidvolume_usd / $base_usd_price; }
                my $minbidvolume_usd = $marginsconf->{$coin}{'minbidvolume'};
                if ( defined $minbidvolume_usd ) { $minbidvolume = $minbidvolume_usd / $base_usd_price; }
                my $maxaskvolume_usd = $marginsconf->{$coin}{'maxaskvolume'};
                if ( defined $maxaskvolume_usd && $coinusdprice > 0 ) { $maxaskvolume = $maxaskvolume_usd / $coinusdprice; }
                my $minaskvolume_usd = $marginsconf->{$coin}{'minaskvolume'};
                if ( defined $minaskvolume_usd && $coinusdprice > 0 ) { $minaskvolume = $minaskvolume_usd / $coinusdprice; }
                if ( (($base eq "BTC") || ($base eq "BTC-segwit")) && ($type eq "erc20") ) {
                    if ( ($erc20fee eq "1") || ($btcfee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume_btc = $btcfee * $btcusdprice / $coinusdprice * 70;
                        $minbidvolume_btc = $btcfee * 70;
                        $minaskvolume_eth = $erc20fee * 100 / $coinusdprice;
                        $minbidvolume_eth = $erc20fee * 100 / $base_usd_price;
                        $minaskvolume = max($minaskvolume_btc,$minaskvolume_eth);
                        $minbidvolume = max($minbidvolume_btc,$minbidvolume_eth);
                    }
                } elsif ( ($type eq "erc20") || (index($base, "ERC20") != -1) || ($base eq "ETH") ) {
                    if ( ($erc20fee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $erc20fee * 100 / $coinusdprice;
                        $minbidvolume = $erc20fee * 100 / $base_usd_price;
                    }
                } elsif (($base eq "BTC") || ($base eq "BTC-segwit")) {
                    if ( ($btcfee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $btcfee * $btcusdprice / $coinusdprice * 70;
                        $minbidvolume = $btcfee * 70;
                    }
                } elsif (($coin eq "BTC") || ($coin eq "BTC-segwit")) {
                    if ( ($btcfee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $btcfee * 70;
                        $minbidvolume = $btcfee * $btcusdprice / $base_usd_price * 70;
                    }
                } elsif ( ($type eq "bep20") || (index($base, "BEP20") != -1) || ($base eq "BNB") ) {
                    if ( ($bep20fee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $bep20fee * 50 / $coinusdprice;
                        $minbidvolume = $bep20fee * 50 / $base_usd_price;
                    }
                } elsif ( ($type eq "avx20") || (index($base, "AVX20") != -1) || ($base eq "AVAX") ) {
                    if ( ($avx20fee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $avx20fee * 100 / $coinusdprice;
                        $minbidvolume = $avx20fee * 100 / $base_usd_price;
                    }
                } elsif ( ($type eq "arb20") || (index($base, "ARB20") != -1) || ($base eq "ETH-ARB20") ) {
                    if ( ($arb20fee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $arb20fee * 100 / $coinusdprice;
                        $minbidvolume = $arb20fee * 100 / $base_usd_price;
                    }
                } elsif ( ($type eq "plg20") || (index($base, "PLG20") != -1) || ($base eq "POL") ) {
                    if ( ($plg20fee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $plg20fee * 100 / $coinusdprice;
                        $minbidvolume = $plg20fee * 100 / $base_usd_price;
                    }
                } elsif ( ($type eq "hrc20") || (index($base, "HRC20") != -1) || ($base eq "ONE") ) {
                    if ( ($hrc20fee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $hrc20fee * 100 / $coinusdprice;
                        $minbidvolume = $hrc20fee * 100 / $base_usd_price;
                    }
                } elsif ( ($type eq "krc20") || (index($base, "KRC20") != -1) || ($base eq "KCS") ) {
                    if ( ($krc20fee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $krc20fee * 100 / $coinusdprice;
                        $minbidvolume = $krc20fee * 100 / $base_usd_price;
                    }
                } elsif ( ($type eq "glm20") || (index($base, "GLM20") != -1) || ($base eq "GLMR") ) {
                    if ( ($glm20fee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $glm20fee * 100 / $coinusdprice;
                        $minbidvolume = $glm20fee * 100 / $base_usd_price;
                    }
                } elsif ( ($type eq "mvr20") || (index($base, "MVR20") != -1) || ($base eq "MOVR") ) {
                    if ( ($mvr20fee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $mvr20fee * 100 / $coinusdprice;
                        $minbidvolume = $mvr20fee * 100 / $base_usd_price;
                    }
                } elsif ($type eq "ewt") {
                    if ( ($ewtfee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $ewtfee * 100 / $coinusdprice;
                        $minbidvolume = $ewtfee * 100 / $base_usd_price;
                    }
                } elsif ($type eq "qrc20") {
                    if ( ($qrc20fee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $qrc20fee * 10 / $coinusdprice;
                        $minbidvolume = $qrc20fee * 10 / $base_usd_price;
                    }
                } elsif ( ($coin eq "QTUM") || ($base eq "QTUM") ) {
                    if ( ($qtumfee eq "1") || ($coinusdprice == 0) ) {
                        $price = 0;
                    } else {
                        $minaskvolume = $qtumfee * 10 / $coinusdprice;
                        $minbidvolume = $qtumfee * 10 / $base_usd_price;
                    }
#                } elsif ($coin eq "DOGE") {
#                    $minaskvolume = 3;
#                    $minbidvolume = $dogeusdprice / $base_usd_price * 3;
#                } elsif ($base eq "DOGE") {
#                    $minaskvolume = $dogeusdprice / $coinusdprice * 3;
#                    $minbidvolume = 3;
#                } elsif ($coin eq "DGB-segwit") {
#                    $minaskvolume = 20;
#                    $minbidvolume = $dgbusdprice / $base_usd_price * 20;
#                } elsif ($base eq "DGB-segwit") {
#                    $minaskvolume = $dgbusdprice / $coinusdprice * 20;
#                    $minbidvolume = 20;
                }
               }

                if (defined $sane_price) {
                    my $saneaskmargin = 0;
                    my $sanebidmargin = 0;
                    if ( defined $marginsconf->{$coin}{'askmargin'} ) { $saneaskmargin = $marginsconf->{$coin}{'askmargin'}; }
                    if ( defined $marginsconf->{$coin}{'bidmargin'} ) { $sanebidmargin = $marginsconf->{$coin}{'bidmargin'}; }
                    my $sanemargin = ($saneaskmargin + $sanebidmargin) / 2 + 0.05;
                    if (($coinusdprice < $sane_price - $sane_price * $sanemargin) || ($coinusdprice > $sane_price + $sane_price * $sanemargin)) {
                        my $bsprice = sprintf("%.8f", $coinusdprice);
                        $sane_price = sprintf("%.8f", $sane_price);
                        print colored ("================= bullshit_price $bsprice for $coin  sane_price $sane_price", 'yellow'),"\n";
                        $price = 0;
                    }
                }

                # https://api.nonkyc.io/api/v2/asset/getbyticker/NAV
                if (defined $nonkyc_info_symbol) {
                    my $nonkyc_info = nonkyc_info($nonkyc_info_symbol);
                    if ( $nonkyc_info ne "1" ) {
                        my $deposit_active = from_json($nonkyc_info)->{"depositActive"};
                        my $withdraw_active = from_json($nonkyc_info)->{"withdrawalActive"};
                        my $delist_check = from_json($nonkyc_info)->{"isDelistCheck"};
                        my $delesting = from_json($nonkyc_info)->{"isDelisting"};
                        if (!$deposit_active) {
                            $bid = undef;
                            print "========= deposits for $coin on nonkyc disabled\n";
                        }
                        if (!$withdraw_active) {
                            $ask = undef;
                            print "========= withdraws for $coin on nonkyc disabled\n";
                        }
                        if (($delist_check) || ($delesting)) {
                            print "========= $coin may be delisted from nonkyc\n";
                        }
                    }
                }

                # https://api.bittrex.com/v3/currencies/XMY
                if (defined $bittrex_info_symbol) {
                    my $bittrex_info = bittrex_info($bittrex_info_symbol);
                    if ( $bittrex_info ne "1" ) {
                        my $online = from_json($bittrex_info)->{"status"};
                        if ($online eq "OFFLINE") {
                            $bid = undef;
                            $ask = undef;
                            my $reason = from_json($bittrex_info)->{"notice"};
                            print "========= $coin is offline on bittrex, reason: $reason\n";
                        }
                    }
                }

                # https://api.binance.com/api/v3/exchangeInfo?symbol=NAVBTC
                if (defined $binance_info_symbol) {
                    my $binance_info = binance_info($binance_info_symbol);
                    if ( $binance_info ne "1" ) {
                        my $status = from_json($binance_info)->{"symbols"}[0]{"status"};
                        if ($status ne "TRADING") {
                            $bid = undef;
                            $ask = undef;
                            print "========= $coin is not trading on binance, reason: $status\n";
                        }
                    }
                }

                # https://api.coinex.com/v2/assets/deposit-withdraw-config?ccy=FIRO
                if (defined $coinex_info_symbol) {
                    my $coinex_info = coinex_info($coinex_info_symbol);
                    if ( $coinex_info ne "1" ) {
                        my $deposit_active = from_json($coinex_info)->{"data"}{"chains"}[0]{"deposit_enabled"};
                        my $withdraw_active = from_json($coinex_info)->{"data"}{"chains"}[0]{"withdraw_enabled"};
                        if (!$deposit_active) {
                            $bid = undef;
                            print "========= deposits for $coin on coinex disabled\n";
                        }
                        if (!$withdraw_active) {
                            $ask = undef;
                            print "========= withdraws for $coin on coinex disabled\n";
                        }
                    }
                }

                if ($price eq "0") {
                    dex_deleteprice_pair($base,$coin);
                } else {
                    my $rel_mintradevol = dex_getmintradevol($coin);
                    my $rel_balance = dex_getbalance($coin);
                    dex_setprice($base,$coin,$bid,$ask,$maxbidvolume,$minbidvolume,$maxaskvolume,$minaskvolume,$bidmargin,$askmargin,$coinusdprice,$rel_mintradevol,$base_mintradevol,$rel_balance,$base_balance);
                }

            }
        } else {
            print "========= base price 0, cancelling orders, base_usd_price $base_usd_price, base_btc_price $base_btc_price\n";
            dex_deleteprice_ticker($base);
            Time::HiRes::sleep(180);
        }
    }


} elsif ( $api eq "binance" ) {
    my $json = read_file("$cwd/mpm.conf.binance.$base");
    my $marginsconf = decode_json($json);
    #my $marginadd = binance_volat();
    my $marginadd = 0;

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_1'} + $marginadd/50);
        my $bidmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_2'} + $marginadd/25);
        my $bidmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_3'} + $marginadd/10);
        my $askmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_1'} + $marginadd/50);
        my $askmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_2'} + $marginadd/25);
        my $askmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_3'} + $marginadd/10);
        my $quantity_1 = $marginsconf->{$coin}{'quantity_1'};
        my $quantity_2 = $marginsconf->{$coin}{'quantity_2'};
        my $quantity_3 = $marginsconf->{$coin}{'quantity_3'};
        my $maxsum_1 = $marginsconf->{$coin}{'maxsum_1'};
        my $maxsum_2 = $marginsconf->{$coin}{'maxsum_2'};
        my $maxsum_3 = $marginsconf->{$coin}{'maxsum_3'};

        binance_cancelorders($base,$coin);

        my $binance_24hr_price = decode_json(binance_24hr_price($base.$coin));
        my $cex_price = sprintf("%.9f", ($binance_24hr_price->{'bidPrice'} + $binance_24hr_price->{'askPrice'} + $binance_24hr_price->{'lastPrice'})/3);
        my $binance_depth = decode_json(binance_depth($base,$coin));

        if ( ($binance_depth ne "1") && ($binance_24hr_price ne "1") ) {
            my $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_1));
            my $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_1));

            if ((($coin eq "BUSD") || ($coin eq "USDT")) && ($base eq "DGB")) {
                $cex_bid_price_1 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_1,$coin) + 0.00001000;
                $cex_ask_price_1 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_1,$coin) - 0.00001000;
            } elsif ((($coin eq "BUSD") || ($coin eq "USDT") || ($coin eq "USDC")) && ($base eq "LTC") || ($base eq "BTC")) {
                $cex_bid_price_1 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_1,$coin) + 0.01000;
                $cex_ask_price_1 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_1,$coin) - 0.01000;
            } elsif (($coin eq "BTC") && ($base eq "LTC")) {
                $cex_bid_price_1 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_1,$coin) + 0.000001;
                $cex_ask_price_1 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_1,$coin) - 0.000001;
            } elsif (( $coin eq "BUSD" ) || ( $coin eq "USDT" ) || ( $coin eq "BNB" )) {
                $cex_bid_price_1 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_1,$coin) + 0.00010000;
                $cex_ask_price_1 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_1,$coin) - 0.00010000;
            } elsif ( $coin eq "ETH" ) {
                $cex_bid_price_1 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_1,$coin) + 0.00000010;
                $cex_ask_price_1 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_1,$coin) - 0.00000010;
            } else {
                $cex_bid_price_1 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_1,$coin) + 0.00000001;
                $cex_ask_price_1 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_1,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_1 eq "0.00000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = $maxbidprice; }
            if ( ( $cex_ask_price_1 eq "0.00000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = $minaskprice; }

            $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_2));
            $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_2));
            if ((($coin eq "BUSD") || ($coin eq "USDT")) && ($base eq "DGB")) {
                $cex_bid_price_2 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_2,$coin) + 0.00001000;
                $cex_ask_price_2 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_2,$coin) - 0.00001000;
            } elsif ((($coin eq "BUSD") || ($coin eq "USDT") || ($coin eq "USDC")) && ($base eq "LTC") || ($base eq "BTC")) {
                $cex_bid_price_2 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_2,$coin) + 0.01000;
                $cex_ask_price_2 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_2,$coin) - 0.01000;
            } elsif (($coin eq "BTC") && ($base eq "LTC")) {
                $cex_bid_price_2 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_2,$coin) + 0.000001;
                $cex_ask_price_2 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_2,$coin) - 0.000001;
            } elsif (( $coin eq "BUSD" ) || ( $coin eq "USDT" ) || ( $coin eq "BNB" )) {
                $cex_bid_price_2 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_2,$coin) + 0.00010000;
                $cex_ask_price_2 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_2,$coin) - 0.00010000;
            } elsif ( $coin eq "ETH" ) {
                $cex_bid_price_2 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_2,$coin) + 0.00000010;
                $cex_ask_price_2 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_2,$coin) - 0.00000010;
            } else {
                $cex_bid_price_2 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_2,$coin) + 0.00000001;
                $cex_ask_price_2 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_2,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_2 eq "0.00000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
            if ( ( $cex_ask_price_2 eq "0.00000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }

            $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_3));
            $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_3));
            if ((($coin eq "BUSD") || ($coin eq "USDT")) && ($base eq "DGB")) {
                $cex_bid_price_3 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_3,$coin) + 0.00001000;
                $cex_ask_price_3 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_3,$coin) - 0.00001000;
            } elsif ((($coin eq "BUSD") || ($coin eq "USDT") || ($coin eq "USDC")) && ($base eq "LTC") || ($base eq "BTC")) {
                $cex_bid_price_3 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_3,$coin) + 0.01000;
                $cex_ask_price_3 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_3,$coin) - 0.01000;
            } elsif (($coin eq "BTC") && ($base eq "LTC")) {
                $cex_bid_price_3 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_3,$coin) + 0.000001;
                $cex_ask_price_3 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_3,$coin) - 0.000001;
            } elsif (( $coin eq "BUSD" ) || ( $coin eq "USDT" ) || ( $coin eq "BNB" )) {
                $cex_bid_price_3 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_3,$coin) + 0.00010000;
                $cex_ask_price_3 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_3,$coin) - 0.00010000;
            } elsif ( $coin eq "ETH" ) {
                $cex_bid_price_3 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_3,$coin) + 0.00000010;
                $cex_ask_price_3 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_3,$coin) - 0.00000010;
            } else {
                $cex_bid_price_3 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_3,$coin) + 0.00000001;
                $cex_ask_price_3 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_3,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_3 eq "0.00000001" ) || ( $cex_bid_price_3 > $maxbidprice ) ) { $cex_bid_price_3 = $maxbidprice; }
            if ( ( $cex_ask_price_3 eq "0.00000001" ) || ( $cex_ask_price_3 < $minaskprice ) ) { $cex_ask_price_3 = $minaskprice; }

            binance_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
            binance_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
            binance_setprice($base,$coin,$cex_bid_price_3,$cex_ask_price_3,$quantity_3);
        }
    }


} elsif ( $api eq "kucoin_wt" ) {
    my $json = read_file("$cwd/mpm.conf.kucoin_wt.$base");
    my $marginsconf = decode_json($json);

    foreach my $coin ( keys %{$marginsconf} ) {
        my $quantity = int(rand(10)) + $marginsconf->{$coin}{'quantity'};

        #kucoin_cancelorders($base,$coin);
        #Time::HiRes::sleep(1);

        my $kucoin_book_price = kucoin_book_price($base,$coin);
        my $book_price = sprintf("%.9f", ($kucoin_book_price->{'bestBid'} + $kucoin_book_price->{'bestAsk'})/2);

        if ( $kucoin_book_price ne "1" ) {
            kucoin_setprice($base,$coin,$book_price,$book_price,$quantity);
        }
    }


} elsif ( $api eq "kucoin" ) {
    my $json = read_file("$cwd/mpm.conf.kucoin.$base");
    my $marginsconf = decode_json($json);
    #my $marginadd = binance_volat();
    my $marginadd = 0;

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_1'} + $marginadd/50);
        my $bidmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_2'} + $marginadd/25);
        my $bidmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_3'} + $marginadd/10);
        my $askmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_1'} + $marginadd/50);
        my $askmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_2'} + $marginadd/25);
        my $askmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_3'} + $marginadd/10);
        my $quantity_1 = $marginsconf->{$coin}{'quantity_1'};
        my $quantity_2 = $marginsconf->{$coin}{'quantity_2'};
        my $quantity_3 = $marginsconf->{$coin}{'quantity_3'};
        my $maxsum_1 = $marginsconf->{$coin}{'maxsum_1'};
        my $maxsum_2 = $marginsconf->{$coin}{'maxsum_2'};
        my $maxsum_3 = $marginsconf->{$coin}{'maxsum_3'};

        kucoin_cancelorders($base,$coin);
        Time::HiRes::sleep(1);

        my $kucoin_price = kucoin_latest_price("$base-$coin");
        my $cex_price = sprintf("%.9f", ($kucoin_price->{"bestBid"} + $kucoin_price->{"bestAsk"} + $kucoin_price->{"price"})/3);

        my $kucoin_depth = kucoin_depth($base,$coin);

        if ( ($kucoin_depth ne "1") && ($kucoin_price ne "1") ) {
            my $maxbidprice = sprintf("%.9f", ($cex_price - $cex_price * $bidmargin_1));
            my $minaskprice = sprintf("%.9f", ($cex_price + $cex_price * $askmargin_1));
            if (( $coin eq "BUSD" ) || ( $coin eq "USDT" ) || ( $coin eq "EUR" )) {
                $cex_bid_price_1 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_1,$coin) + 0.00010000;
                $cex_ask_price_1 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_1,$coin) - 0.00010000;
            } elsif (( $coin eq "BTC" ) && ( $base eq "KMD" )) {
                $cex_bid_price_1 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_1,$coin) + 0.000000001;
                $cex_ask_price_1 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_1,$coin) - 0.000000001;
            } else {
                $cex_bid_price_1 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_1,$coin) + 0.00000001;
                $cex_ask_price_1 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_1,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_1 eq "0.00000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = $maxbidprice; }
            if ( ( $cex_ask_price_1 eq "0.00000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = $minaskprice; }

            $maxbidprice = sprintf("%.9f", ($cex_price - $cex_price * $bidmargin_2));
            $minaskprice = sprintf("%.9f", ($cex_price + $cex_price * $askmargin_2));
            if (( $coin eq "BUSD" ) || ( $coin eq "USDT" ) || ( $coin eq "EUR" )) {
                $cex_bid_price_2 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_2,$coin) + 0.00010000;
                $cex_ask_price_2 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_2,$coin) - 0.00010000;
            } elsif (( $coin eq "BTC" ) && ( $base eq "KMD" )) {
                $cex_bid_price_2 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_2,$coin) + 0.000000001;
                $cex_ask_price_2 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_2,$coin) - 0.000000001;
            } else {
                $cex_bid_price_2 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_2,$coin) + 0.00000001;
                $cex_ask_price_2 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_2,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_2 eq "0.00000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
            if ( ( $cex_ask_price_2 eq "0.00000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }

            $maxbidprice = sprintf("%.9f", ($cex_price - $cex_price * $bidmargin_3));
            $minaskprice = sprintf("%.9f", ($cex_price + $cex_price * $askmargin_3));
            if (( $coin eq "BUSD" ) || ( $coin eq "USDT" ) || ( $coin eq "EUR" )) {
                $cex_bid_price_3 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_3,$coin) + 0.00010000;
                $cex_ask_price_3 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_3,$coin) - 0.00010000;
            } elsif (( $coin eq "BTC" ) && ( $base eq "KMD" )) {
                $cex_bid_price_3 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_3,$coin) + 0.000000001;
                $cex_ask_price_3 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_3,$coin) - 0.000000001;
            } else {
                $cex_bid_price_3 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_3,$coin) + 0.00000001;
                $cex_ask_price_3 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_3,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_3 eq "0.00000001" ) || ( $cex_bid_price_3 > $maxbidprice ) ) { $cex_bid_price_3 = $maxbidprice; }
            if ( ( $cex_ask_price_3 eq "0.00000001" ) || ( $cex_ask_price_3 < $minaskprice ) ) { $cex_ask_price_3 = $minaskprice; }

            kucoin_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
            kucoin_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
            kucoin_setprice($base,$coin,$cex_bid_price_3,$cex_ask_price_3,$quantity_3);
        }
    }


} elsif ( $api eq "mandala" ) {
    my $json = read_file("$cwd/mpm.conf.mandala.$base");
    my $marginsconf = decode_json($json);
    #my $marginadd = mandala_volat();
    my $marginadd = 0;

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_1'} + $marginadd/50);
        my $bidmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_2'} + $marginadd/25);
        my $bidmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_3'} + $marginadd/10);
        my $askmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_1'} + $marginadd/50);
        my $askmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_2'} + $marginadd/25);
        my $askmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_3'} + $marginadd/10);
        my $quantity_1 = $marginsconf->{$coin}{'quantity_1'};
        my $quantity_2 = $marginsconf->{$coin}{'quantity_2'};
        my $quantity_3 = $marginsconf->{$coin}{'quantity_3'};
        my $maxsum_1 = $marginsconf->{$coin}{'maxsum_1'};
        my $maxsum_2 = $marginsconf->{$coin}{'maxsum_2'};
        my $maxsum_3 = $marginsconf->{$coin}{'maxsum_3'};

        mandala_cancelorders($base,$coin);

        my $mandala_book_price = decode_json(binance_book_price($base,$coin));
        my $cex_price = sprintf("%.8f", ($mandala_book_price->{'bidPrice'} + $mandala_book_price->{'askPrice'})/2);
        my $mandala_depth = decode_json(binance_depth($base,$coin));

        if ( ($mandala_depth ne "1") && ($mandala_book_price ne "1") ) {
            my $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_1));
            my $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_1));
            if ((($coin eq "BUSD") || ($coin eq "USDT")) && ($base eq "DGB")) {
                $cex_bid_price_1 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_1,$coin) + 0.00001000;
                $cex_ask_price_1 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_1,$coin) - 0.00001000;
            } elsif ((($coin eq "BUSD") || ($coin eq "USDT") || ($coin eq "TUSD")) && ($base eq "LTC")) {
                $cex_bid_price_1 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_1,$coin) + 0.01000;
                $cex_ask_price_1 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_1,$coin) - 0.01000;
            } elsif (($coin eq "BTC") && ($base eq "LTC")) {
                $cex_bid_price_1 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_1,$coin) + 0.000001;
                $cex_ask_price_1 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_1,$coin) - 0.000001;
            } elsif (( $coin eq "BUSD" ) || ( $coin eq "USDT" ) || ( $coin eq "BNB" )) {
                $cex_bid_price_1 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_1,$coin) + 0.00010000;
                $cex_ask_price_1 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_1,$coin) - 0.00010000;
            } elsif ( $coin eq "ETH" ) {
                $cex_bid_price_1 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_1,$coin) + 0.00000010;
                $cex_ask_price_1 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_1,$coin) - 0.00000010;
            } else {
                $cex_bid_price_1 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_1,$coin) + 0.00000001;
                $cex_ask_price_1 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_1,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_1 eq "0.00000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = $maxbidprice; }
            if ( ( $cex_ask_price_1 eq "0.00000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = $minaskprice; }

            $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_2));
            $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_2));
            if ((($coin eq "BUSD") || ($coin eq "USDT")) && ($base eq "DGB")) {
                $cex_bid_price_2 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_2,$coin) + 0.00001000;
                $cex_ask_price_2 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_2,$coin) - 0.00001000;
            } elsif ((($coin eq "BUSD") || ($coin eq "USDT") || ($coin eq "TUSD")) && ($base eq "LTC")) {
                $cex_bid_price_2 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_2,$coin) + 0.01000;
                $cex_ask_price_2 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_2,$coin) - 0.01000;
            } elsif (($coin eq "BTC") && ($base eq "LTC")) {
                $cex_bid_price_2 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_2,$coin) + 0.000001;
                $cex_ask_price_2 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_2,$coin) - 0.000001;
            } elsif (( $coin eq "BUSD" ) || ( $coin eq "USDT" ) || ( $coin eq "BNB" )) {
                $cex_bid_price_2 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_2,$coin) + 0.00010000;
                $cex_ask_price_2 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_2,$coin) - 0.00010000;
            } elsif ( $coin eq "ETH" ) {
                $cex_bid_price_2 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_2,$coin) + 0.00000010;
                $cex_ask_price_2 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_2,$coin) - 0.00000010;
            } else {
                $cex_bid_price_2 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_2,$coin) + 0.00000001;
                $cex_ask_price_2 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_2,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_2 eq "0.00000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
            if ( ( $cex_ask_price_2 eq "0.00000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }

            $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_3));
            $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_3));
            if ((($coin eq "BUSD") || ($coin eq "USDT")) && ($base eq "DGB")) {
                $cex_bid_price_3 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_3,$coin) + 0.00001000;
                $cex_ask_price_3 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_3,$coin) - 0.00001000;
            } elsif ((($coin eq "BUSD") || ($coin eq "USDT") || ($coin eq "TUSD")) && ($base eq "LTC")) {
                $cex_bid_price_3 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_3,$coin) + 0.01000;
                $cex_ask_price_3 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_3,$coin) - 0.01000;
            } elsif (($coin eq "BTC") && ($base eq "LTC")) {
                $cex_bid_price_3 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_3,$coin) + 0.000001;
                $cex_ask_price_3 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_3,$coin) - 0.000001;
            } elsif (( $coin eq "BUSD" ) || ( $coin eq "USDT" ) || ( $coin eq "BNB" )) {
                $cex_bid_price_3 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_3,$coin) + 0.00010000;
                $cex_ask_price_3 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_3,$coin) - 0.00010000;
            } elsif ( $coin eq "ETH" ) {
                $cex_bid_price_3 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_3,$coin) + 0.00000010;
                $cex_ask_price_3 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_3,$coin) - 0.00000010;
            } else {
                $cex_bid_price_3 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_3,$coin) + 0.00000001;
                $cex_ask_price_3 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_3,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_3 eq "0.00000001" ) || ( $cex_bid_price_3 > $maxbidprice ) ) { $cex_bid_price_3 = $maxbidprice; }
            if ( ( $cex_ask_price_3 eq "0.00000001" ) || ( $cex_ask_price_3 < $minaskprice ) ) { $cex_ask_price_3 = $minaskprice; }

            mandala_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
            mandala_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
            mandala_setprice($base,$coin,$cex_bid_price_3,$cex_ask_price_3,$quantity_3);
        }
    }


} elsif ( $api eq "bitvavo" ) {
    my $json = read_file("$cwd/mpm.conf.bitvavo.$base");
    my $marginsconf = decode_json($json);
    #my $marginadd = binance_volat();
    my $marginadd = 0;

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_1'} + $marginadd/50);
        my $bidmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_2'} + $marginadd/25);
        my $bidmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_3'} + $marginadd/10);
        my $askmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_1'} + $marginadd/50);
        my $askmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_2'} + $marginadd/25);
        my $askmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_3'} + $marginadd/10);
        my $quantity_1 = $marginsconf->{$coin}{'quantity_1'};
        my $quantity_2 = $marginsconf->{$coin}{'quantity_2'};
        my $quantity_3 = $marginsconf->{$coin}{'quantity_3'};
        my $maxsum_1 = $marginsconf->{$coin}{'maxsum_1'};
        my $maxsum_2 = $marginsconf->{$coin}{'maxsum_2'};
        my $maxsum_3 = $marginsconf->{$coin}{'maxsum_3'};

        bitvavo_cancelorders($base,$coin);

        my $bitvavo_book_price = decode_json(bitvavo_book_price($base,$coin));
        my $cex_price = sprintf("%.5f", ($bitvavo_book_price->{'bid'} + $bitvavo_book_price->{'ask'})/2);
        my $bitvavo_depth = decode_json(bitvavo_depth($base,$coin));

        if ( ($bitvavo_depth ne "1") && ($bitvavo_book_price ne "1") ) {
            my $maxbidprice = sprintf("%.5f", ($cex_price - $cex_price * $bidmargin_1));
            my $minaskprice = sprintf("%.5f", ($cex_price + $cex_price * $askmargin_1));
            $cex_bid_price_1 = sprintf("%.5f", (calc_bestprice_sum($bitvavo_depth->{'bids'},$maxsum_1,$coin) + 0.00001));
            $cex_ask_price_1 = sprintf("%.5f", (calc_bestprice_sum($bitvavo_depth->{'asks'},$maxsum_1,$coin) - 0.00001));
            if ( ( $cex_bid_price_1 eq "0.0001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = $maxbidprice; }
            if ( ( $cex_ask_price_1 eq "0.0001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = $minaskprice; }

            $maxbidprice = sprintf("%.5f", ($cex_price - $cex_price * $bidmargin_2));
            $minaskprice = sprintf("%.5f", ($cex_price + $cex_price * $askmargin_2));
            $cex_bid_price_2 = sprintf("%.5f", (calc_bestprice_sum($bitvavo_depth->{'bids'},$maxsum_2,$coin) + 0.00001));
            $cex_ask_price_2 = sprintf("%.5f", (calc_bestprice_sum($bitvavo_depth->{'asks'},$maxsum_2,$coin) - 0.00001));
            if ( ( $cex_bid_price_2 eq "0.0001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
            if ( ( $cex_ask_price_2 eq "0.0001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }

            $maxbidprice = sprintf("%.5f", ($cex_price - $cex_price * $bidmargin_3));
            $minaskprice = sprintf("%.5f", ($cex_price + $cex_price * $askmargin_3));
            $cex_bid_price_3 = sprintf("%.5f", (calc_bestprice_sum($bitvavo_depth->{'bids'},$maxsum_3,$coin) + 0.00001));
            $cex_ask_price_3 = sprintf("%.5f", (calc_bestprice_sum($bitvavo_depth->{'asks'},$maxsum_3,$coin) - 0.00001));
            if ( ( $cex_bid_price_3 eq "0.0001" ) || ( $cex_bid_price_3 > $maxbidprice ) ) { $cex_bid_price_3 = $maxbidprice; }
            if ( ( $cex_ask_price_3 eq "0.0001" ) || ( $cex_ask_price_3 < $minaskprice ) ) { $cex_ask_price_3 = $minaskprice; }

            bitvavo_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
            bitvavo_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
            bitvavo_setprice($base,$coin,$cex_bid_price_3,$cex_ask_price_3,$quantity_3);
        }
    }


} elsif ( $api eq "bittrex" ) {
    my $json = read_file("$cwd/mpm.conf.bittrex.$base");
    my $marginsconf = decode_json($json);
    #my $marginadd = binance_volat();
    my $marginadd = 0;
    my $cex_price = 0;

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_1'} + $marginadd/50);
        my $bidmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_2'} + $marginadd/25);
        my $bidmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_3'} + $marginadd/10);
        my $askmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_1'} + $marginadd/50);
        my $askmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_2'} + $marginadd/25);
        my $askmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_3'} + $marginadd/10);
        my $quantity_1 = $marginsconf->{$coin}{'quantity_1'};
        my $quantity_2 = $marginsconf->{$coin}{'quantity_2'};
        my $quantity_3 = $marginsconf->{$coin}{'quantity_3'};
        my $maxsum_1 = $marginsconf->{$coin}{'maxsum_1'};
        my $maxsum_2 = $marginsconf->{$coin}{'maxsum_2'};
        my $maxsum_3 = $marginsconf->{$coin}{'maxsum_3'};

        bittrex_cancelorders($base,$coin);

        my $bittrex_price = bittrex_latest_price($base."-".$coin);
        my $askrate = from_json($bittrex_price)->{"askRate"};
        my $bidrate = from_json($bittrex_price)->{"bidRate"};
        if (($askrate > 0) && ($bidrate > 0)) {
            $cex_price = sprintf("%.9f", ($askrate + $bidrate + from_json($bittrex_price)->{"lastTradeRate"}) / 3);
        }

        my $bittrex_depth = decode_json(bittrex_depth($base."-".$coin));

        if ( ($bittrex_depth ne "1") && ($cex_price > 0) ) {
            my $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_1));
            my $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_1));
            if ($coin eq "BTC") {
                $cex_bid_price_1 = sprintf("%.8f", (calc_bestprice_sum_bittrex($bittrex_depth->{'bid'},$maxsum_1,$coin) + 0.00000001));
                $cex_ask_price_1 = sprintf("%.8f", (calc_bestprice_sum_bittrex($bittrex_depth->{'ask'},$maxsum_1,$coin) - 0.00000001));
            } else {
                $cex_bid_price_1 = sprintf("%.3f", (calc_bestprice_sum_bittrex($bittrex_depth->{'bid'},$maxsum_1,$coin) + 0.001));
                $cex_ask_price_1 = sprintf("%.3f", (calc_bestprice_sum_bittrex($bittrex_depth->{'ask'},$maxsum_1,$coin) - 0.001));
            }
            if ( ( $cex_bid_price_1 eq "0.00000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = $maxbidprice; }
            if ( ( $cex_ask_price_1 eq "0.00000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = $minaskprice; }

            $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_2));
            $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_2));
            if ($coin eq "BTC") {
                $cex_bid_price_2 = sprintf("%.8f", (calc_bestprice_sum_bittrex($bittrex_depth->{'bid'},$maxsum_2,$coin) + 0.00000001));
                $cex_ask_price_2 = sprintf("%.8f", (calc_bestprice_sum_bittrex($bittrex_depth->{'ask'},$maxsum_2,$coin) - 0.00000001));
            } else {
                $cex_bid_price_2 = sprintf("%.3f", (calc_bestprice_sum_bittrex($bittrex_depth->{'bid'},$maxsum_2,$coin) + 0.001));
                $cex_ask_price_2 = sprintf("%.3f", (calc_bestprice_sum_bittrex($bittrex_depth->{'ask'},$maxsum_2,$coin) - 0.001));
            }
            if ( ( $cex_bid_price_2 eq "0.00000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
            if ( ( $cex_ask_price_2 eq "0.00000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }

            $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_3));
            $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_3));
            if ($coin eq "BTC") {
                $cex_bid_price_3 = sprintf("%.8f", (calc_bestprice_sum_bittrex($bittrex_depth->{'bid'},$maxsum_3,$coin) + 0.00000001));
                $cex_ask_price_3 = sprintf("%.8f", (calc_bestprice_sum_bittrex($bittrex_depth->{'ask'},$maxsum_3,$coin) - 0.00000001));
            } else {
                $cex_bid_price_3 = sprintf("%.3f", (calc_bestprice_sum_bittrex($bittrex_depth->{'bid'},$maxsum_3,$coin) + 0.001));
                $cex_ask_price_3 = sprintf("%.3f", (calc_bestprice_sum_bittrex($bittrex_depth->{'ask'},$maxsum_3,$coin) - 0.001));
            }
            if ( ( $cex_bid_price_3 eq "0.00000001" ) || ( $cex_bid_price_3 > $maxbidprice ) ) { $cex_bid_price_3 = $maxbidprice; }
            if ( ( $cex_ask_price_3 eq "0.00000001" ) || ( $cex_ask_price_3 < $minaskprice ) ) { $cex_ask_price_3 = $minaskprice; }

            bittrex_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
            bittrex_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
            bittrex_setprice($base,$coin,$cex_bid_price_3,$cex_ask_price_3,$quantity_3);
        }
    }


} elsif ( $api eq "coinex" ) {
    my $json = read_file("$cwd/mpm.conf.coinex.$base");
    my $marginsconf = decode_json($json);
    #my $marginadd = binance_volat();
    my $marginadd = 0;
    my $cex_price = 0;

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_1'} + $marginadd/15);
        my $bidmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_2'} + $marginadd/30);
        my $bidmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_3'} + $marginadd/50);
        my $askmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_1'} + $marginadd/15);
        my $askmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_2'} + $marginadd/30);
        my $askmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_3'} + $marginadd/50);
        my $quantity_1 = $marginsconf->{$coin}{'quantity_1'};
        my $quantity_2 = $marginsconf->{$coin}{'quantity_2'};
        my $quantity_3 = $marginsconf->{$coin}{'quantity_3'};
        my $maxsum_1 = $marginsconf->{$coin}{'maxsum_1'};
        my $maxsum_2 = $marginsconf->{$coin}{'maxsum_2'};
        my $maxsum_3 = $marginsconf->{$coin}{'maxsum_3'};

        coinex_cancelorders($base,$coin);

        my $coinex_price = coinex_latest_price($base.$coin);
        my $sell = from_json($coinex_price)->{"data"}{"ticker"}{"sell"};
        my $buy = from_json($coinex_price)->{"data"}{"ticker"}{"buy"};
        if (($sell > 0) && ($buy > 0)) {
            $cex_price = sprintf("%.10f", ($sell + $buy + from_json($coinex_price)->{"data"}{"ticker"}{"last"})/3);
        }

        my $coinex_depth = coinex_depth($base,$coin);

        if ( ($coinex_depth ne "1") && ($cex_price > 0) ) {
            my $maxbidprice = sprintf("%.10f", ($cex_price - $cex_price * $bidmargin_1));
            my $minaskprice = sprintf("%.10f", ($cex_price + $cex_price * $askmargin_1));
            if ( ($base eq "ARRR") && ($coin eq "USDT") ) {
                $cex_bid_price_1 = sprintf("%.4f", (calc_bestprice_sum($coinex_depth->{'bids'},$maxsum_1,$coin) + 0.0001));
                $cex_ask_price_1 = sprintf("%.4f", (calc_bestprice_sum($coinex_depth->{'asks'},$maxsum_1,$coin) - 0.0001));
            } elsif ( $coin eq "USDT" ) {
                $cex_bid_price_1 = sprintf("%.6f", (calc_bestprice_sum($coinex_depth->{'bids'},$maxsum_1,$coin) + 0.000001));
                $cex_ask_price_1 = sprintf("%.6f", (calc_bestprice_sum($coinex_depth->{'asks'},$maxsum_1,$coin) - 0.000001));
            } else {
                $cex_bid_price_1 = sprintf("%.10f", (calc_bestprice_sum($coinex_depth->{'bids'},$maxsum_1,$coin) + 0.0000000001));
                $cex_ask_price_1 = sprintf("%.10f", (calc_bestprice_sum($coinex_depth->{'asks'},$maxsum_1,$coin) - 0.0000000001));
            }
            if ( ( $cex_bid_price_1 eq "0.0000000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = $maxbidprice; }
            if ( ( $cex_ask_price_1 eq "0.0000000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = $minaskprice; }

            $maxbidprice = sprintf("%.10f", ($cex_price - $cex_price * $bidmargin_2));
            $minaskprice = sprintf("%.10f", ($cex_price + $cex_price * $askmargin_2));
            if ( ($base eq "ARRR") && ($coin eq "USDT") ) {
                $cex_bid_price_2 = sprintf("%.4f", (calc_bestprice_sum($coinex_depth->{'bids'},$maxsum_2,$coin) + 0.0001));
                $cex_ask_price_2 = sprintf("%.4f", (calc_bestprice_sum($coinex_depth->{'asks'},$maxsum_2,$coin) - 0.0001));
            } elsif ( $coin eq "USDT" ) {
                $cex_bid_price_2 = sprintf("%.6f", (calc_bestprice_sum($coinex_depth->{'bids'},$maxsum_2,$coin) + 0.000001));
                $cex_ask_price_2 = sprintf("%.6f", (calc_bestprice_sum($coinex_depth->{'asks'},$maxsum_2,$coin) - 0.000001));
            } else {
                $cex_bid_price_2 = sprintf("%.10f", (calc_bestprice_sum($coinex_depth->{'bids'},$maxsum_2,$coin) + 0.0000000001));
                $cex_ask_price_2 = sprintf("%.10f", (calc_bestprice_sum($coinex_depth->{'asks'},$maxsum_2,$coin) - 0.0000000001));
            }
            if ( ( $cex_bid_price_2 eq "0.0000000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
            if ( ( $cex_ask_price_2 eq "0.0000000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }

            $maxbidprice = sprintf("%.10f", ($cex_price - $cex_price * $bidmargin_3));
            $minaskprice = sprintf("%.10f", ($cex_price + $cex_price * $askmargin_3));
            if ( ($base eq "ARRR") && ($coin eq "USDT") ) {
                $cex_bid_price_3 = sprintf("%.4f", (calc_bestprice_sum($coinex_depth->{'bids'},$maxsum_3,$coin) + 0.0001));
                $cex_ask_price_3 = sprintf("%.4f", (calc_bestprice_sum($coinex_depth->{'asks'},$maxsum_3,$coin) - 0.0001));
            } elsif ( $coin eq "USDT" ) {
                $cex_bid_price_3 = sprintf("%.6f", (calc_bestprice_sum($coinex_depth->{'bids'},$maxsum_3,$coin) + 0.000001));
                $cex_ask_price_3 = sprintf("%.6f", (calc_bestprice_sum($coinex_depth->{'asks'},$maxsum_3,$coin) - 0.000001));
            } else {
                $cex_bid_price_3 = sprintf("%.10f", (calc_bestprice_sum($coinex_depth->{'bids'},$maxsum_3,$coin) + 0.0000000001));
                $cex_ask_price_3 = sprintf("%.10f", (calc_bestprice_sum($coinex_depth->{'asks'},$maxsum_3,$coin) - 0.0000000001));
            }
            if ( ( $cex_bid_price_3 eq "0.0000000001" ) || ( $cex_bid_price_3 > $maxbidprice ) ) { $cex_bid_price_3 = $maxbidprice; }
            if ( ( $cex_ask_price_3 eq "0.0000000001" ) || ( $cex_ask_price_3 < $minaskprice ) ) { $cex_ask_price_3 = $minaskprice; }

            coinex_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
            coinex_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
            coinex_setprice($base,$coin,$cex_bid_price_3,$cex_ask_price_3,$quantity_3);
        }
    }

} else {
    print "API not found\n";
}

