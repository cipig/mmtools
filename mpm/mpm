#!/usr/bin/perl

use warnings;
use LWP::UserAgent;
use JSON;
use File::Slurp qw(read_file);
use File::Basename;
use MIME::Base64;
use Digest::SHA qw(hmac_sha256_hex);
use Digest::SHA qw(hmac_sha512_base64);
#use Data::Dumper;


my $maxgasprice = 15;
my $gaspriceurl = "https://www.etherchain.org/api/gasPriceOracle";
my $gasprice = from_json(getgasprice())->{'standard'};
my $binance_apikey = "";
my $binance_seckey = "";
my $crex24_apikey = "";
my $crex24_seckey = decode_base64("");
my $base = "KMD";
my $userpass =  $ENV{'userpass'};
my $api = $ARGV[0];
my $cex = $ARGV[1];
my $cwd = dirname($0);
my $json = read_file("$cwd/mpm.conf");
my $marginsconf = decode_json($json);
my $quantity = $marginsconf->{$base}{'quantity'};


sub getgasprice {
    my $ua = LWP::UserAgent->new;
    $ua->agent("Mozilla");
    $ua->timeout(15);
    my $req = HTTP::Request->new(GET => $gaspriceurl);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $gaspriceurl, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
        }
}


sub apipaprika {
    my $url = "https://api.coinpaprika.com/v1/price-converter?base_currency_id=".$_[1]."&quote_currency_id=".$_[0]."&amount=1";
    my $ua = LWP::UserAgent->new;
    $ua->agent("Mozilla");
    $ua->timeout(15);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
        }
}


sub apicmcpaid {
    my $baseurl = "https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest?";
    my $ids = "id=";
    my $rel = "&convert=$_[0]";
    my $cmc_apikey = "&CMC_PRO_API_KEY=x";

    foreach my $coin ( keys %{$marginsconf} ) {
        my $cmcid = $marginsconf->{$coin}{'cmcid'};
        $ids .= $cmcid.",";
    }
    chop($ids);
    my $url = $baseurl.$ids.$rel.$cmc_apikey;
    my $ua = LWP::UserAgent->new;
    $ua->agent("Mozilla");
    $ua->timeout(15);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
        }
}


sub binance_latest_price {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.binance.com/api/v3/ticker/price?symbol=".$base.$coin;
    my $ua = LWP::UserAgent->new;
    $ua->agent("Mozilla");
    $ua->timeout(15);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
        }
}


sub binance_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.binance.com/api/v1/depth?symbol=".$base.$coin."&limit=20";
    my $ua = LWP::UserAgent->new;
    $ua->agent("Mozilla");
    $ua->timeout(15);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
        }
}


sub binance_getorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $command = "symbol=".$base.$coin."&timestamp=".time()*1000;
    my $signature = hmac_sha256_hex($command, $binance_seckey);
    my $url = "https://api.binance.com/api/v3/openOrders?".$command."&signature=".$signature;

    my $ua = LWP::UserAgent->new;
    my $req = HTTP::Request->new(GET => $url);
    $req->header('X-MBX-APIKEY' => $binance_apikey);
    my $resp = $ua->request($req);
    return $resp->content;
}


sub binance_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $ua = LWP::UserAgent->new;
    $req = HTTP::Request->new(DELETE => 'https://api.binance.com/api/v3/order');
    $req->header('X-MBX-APIKEY' => $binance_apikey);

    my $orders = decode_json(binance_getorders($base,$coin));
    foreach my $order( @$orders ) {
        my $orderid = $order->{'clientOrderId'};
        $command = "symbol=".$base.$coin."&origClientOrderId=".$orderid."&timestamp=".time()*1000;
        $signature = hmac_sha256_hex($command, $binance_seckey);
        $body = $command."&signature=".$signature;
        $req->content($body);
        $resp = $ua->request($req);
        #print $resp->content."\n";
    }
}


sub crex24_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];
    my $urlpath = "/v2/trading/cancelOrdersByInstrument";
    my $nonce = time();
    my $body = '{"instruments":["'.$base.'-'.$coin.'"]}';
    my $command = $urlpath . $nonce . $body;
    my $signature = hmac_sha512_base64($command,$crex24_seckey);
    while (length($signature) % 4) {
        $signature .= '=';
    }

    my $ua = LWP::UserAgent->new;
    $req = HTTP::Request->new(POST => 'https://api.crex24.com/v2/trading/cancelOrdersByInstrument');
    $req->header('X-CREX24-API-KEY' => $crex24_apikey,
                 'X-CREX24-API-NONCE' => $nonce,
                 'X-CREX24-API-SIGN' => $signature);

    $req->content($body);
    my $resp = $ua->request($req);
    #print $resp->content."\n";
    sleep(1);
}


sub binance_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = undef;
    my $ask = undef;
    if ( $coin eq "ETH" ) {
        $bid = sprintf("%.6f",$_[2]);
        $ask = sprintf("%.6f",$_[3]);
    } else {
        $bid = sprintf("%.7f",$_[2]);
        $ask = sprintf("%.7f",$_[3]);
    }
    my $quantity = sprintf("%u",$_[4]);

    my $ua = LWP::UserAgent->new;
    my $req = HTTP::Request->new(POST => 'https://api.binance.com/api/v3/order');
    $req->header('X-MBX-APIKEY' => $binance_apikey);

    print "$base/$coin size ".sprintf("%03d",$quantity);

    if ( defined $bid ) {
        my $command = "symbol=".$base.$coin."&side=BUY&type=LIMIT_MAKER&newOrderRespType=RESULT&quantity=".$quantity."&price=".$bid."&newClientOrderId=mybuyid".$quantity."&timestamp=".time()*1000;
        my $signature = hmac_sha256_hex($command, $binance_seckey);
        my $body = $command."&signature=".$signature;
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " bid ".$bid;
        } else {
            print " bid 0.0000000";
            #print " ".$resp->content;
        }
    }

    if ( defined $ask ) {
	my $command = "symbol=".$base.$coin."&side=SELL&type=LIMIT_MAKER&newOrderRespType=RESULT&quantity=".$quantity."&price=".$ask."&newClientOrderId=mysellid".$quantity."&timestamp=".time()*1000;
	my $signature = hmac_sha256_hex($command, $binance_seckey);
        my $body = $command."&signature=".$signature;
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " ask ".$ask."\n";
        } else {
            print " ask 0.0000000\n";
            #print " ".$resp->content."\n";
        }
    }
}


sub crex24_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = $_[2];
    my $ask = $_[3];
    my $quantity = sprintf("%u",$_[4]);
    my $urlpath = "/v2/trading/placeOrder";

    print "$base/$coin size ".sprintf("%03d",$quantity);

    if ( defined $bid ) {
        my $nonce = time();
        my $body = '{"instrument":"'.$base.'-'.$coin.'","side":"buy","volume":'.$quantity.',"price":'.$bid.'}';
        my $command = $urlpath . $nonce . $body;
        my $signature = hmac_sha512_base64($command,$crex24_seckey);
        while (length($signature) % 4) {
            $signature .= '=';
        }
        my $ua = LWP::UserAgent->new;
        $req = HTTP::Request->new(POST => 'https://api.crex24.com/v2/trading/placeOrder');
        $req->header('X-CREX24-API-KEY' => $crex24_apikey,
                     'X-CREX24-API-NONCE' => $nonce,
                     'X-CREX24-API-SIGN' => $signature);
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " bid ".$bid;
        } else {
            print " bid 0.0000000";
            #print " ".$resp->content;
        }
        sleep(1);
    }

    if ( defined $ask ) {
        my $nonce = time();
        my $body = '{"instrument":"'.$base.'-'.$coin.'","side":"sell","volume":'.$quantity.',"price":'.$ask.'}';
        my $command = $urlpath . $nonce . $body;
        my $signature = hmac_sha512_base64($command,$crex24_seckey);
        while (length($signature) % 4) {
            $signature .= '=';
        }
        my $ua = LWP::UserAgent->new;
        $req = HTTP::Request->new(POST => 'https://api.crex24.com/v2/trading/placeOrder');
        $req->header('X-CREX24-API-KEY' => $crex24_apikey,
                     'X-CREX24-API-NONCE' => $nonce,
                     'X-CREX24-API-SIGN' => $signature);
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " ask ".$ask."\n";
        } else {
            print " ask 0.0000000\n";
            #print " ".$resp->content."\n";
        }
        sleep(1);
    }
}


sub dex_setprice {
    my $price = $_[2];
    my $bid = undef;
    my $ask = undef;
    my $command = undef;

    if ( defined $marginsconf->{$_[1]}{'askmargin'} ) {
        $ask = sprintf("%.8f", $price + $price * $marginsconf->{$_[1]}{'askmargin'});
    }
    if ( defined $marginsconf->{$_[1]}{'bidmargin'} ) {
        $bid = sprintf("%.8f", 1 / ($price - $price * $marginsconf->{$_[1]}{'bidmargin'}));
    }

    my $ua = LWP::UserAgent->new;
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    if ( defined $ask ) {
	$command = '{"userpass":"'.$userpass.'","method":"setprice","base":"'.$_[1].'","rel":"'.$_[0].'","price":'.$ask.',"max":true}';
        $req->content($command);
        my $resp = $ua->request($req);
        my $uuid = from_json($resp->content)->{'result'}{'uuid'};
        if ( !defined $uuid ) { $uuid = "error"; }
        print "$_[1]/$_[0] ask ".sprintf("%.8f",$ask)." ".$uuid." ";
    }

    if ( defined $bid ) {
	$command = '{"userpass":"'.$userpass.'","method":"setprice","base":"'.$_[0].'","rel":"'.$_[1].'","price":'.$bid.',"max":true}';
        $req->content($command);
        $resp = $ua->request($req);
        my $uuid = from_json($resp->content)->{'result'}{'uuid'};
        if ( !defined $uuid ) { $uuid = "error"; }
        print "bid ".sprintf("%.8f",1/$bid)." ".$uuid."\n";
    }
}


sub dex_deleteprice {
    my $ua = LWP::UserAgent->new;
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    $command = '{"userpass":"'.$userpass.'","method":"cancel_all_orders","cancel_by":{"type":"Pair","data":{"base":"'.$_[1].'","rel":"'.$_[0].'"}}}';
    $req->content($command);
    my $resp = $ua->request($req);
    print "$_[0]/$_[1] ".$resp->content;

    $command = '{"userpass":"'.$userpass.'","method":"cancel_all_orders","cancel_by":{"type":"Pair","data":{"base":"'.$_[0].'","rel":"'.$_[1].'"}}}';
    $req->content($command);
    $resp = $ua->request($req);
    print " ".$resp->content."\n";
}


sub calc_bestbidprice {
    my $quantity = $_[1];
    my $coin = $_[2];
    foreach (@{$_[0]}) {
        my @array = $_;
        my $price = $array[0][0];
        my $volume = $array[0][1];
        if ( $volume > $quantity ) {
            if ( $coin eq "ETH" ) {
                return $price + 0.00000100;
            } else {
                return $price + 0.00000010;
            }
            last;
        }
    }
}


sub calc_bestaskprice {
    my $quantity = $_[1];
    my $coin = $_[2];
    foreach (@{$_[0]}) {
        my @array = $_;
        my $price = $array[0][0];
        my $volume = $array[0][1];
        if ( $volume > $quantity ) {
            if ( $coin eq "ETH" ) {
                return $price - 0.00000100;
            } else {
                return $price - 0.00000010;
            }
            last;
        }
    }
}


if ( $api eq "cmcpaid" ) {
    my $prices = apicmcpaid($base);
    if ( defined $prices ) {
        foreach my $coin ( keys %{$marginsconf} ) {
            if ( $base ne $coin ) {
                my $cmcid = $marginsconf->{$coin}{'cmcid'};
                my $erc20 = $marginsconf->{$coin}{'erc20'};
                if ( !defined $erc20 ) { $erc20 = "0"; }
                my $price = from_json($prices)->{'data'}{$cmcid}{'quote'}{$base}{'price'};
                if ( $erc20 eq "0" ) {
                    dex_setprice($base,$coin,$price);
                } elsif ( ($erc20 eq "1") && ($gasprice < $maxgasprice) ) {
                    dex_setprice($base,$coin,$price);
                } else {
                    dex_deleteprice($base,$coin);
                }
            }
        }
    }
} elsif ( $api eq "coinpaprika" ) {
    my $basepapid = $marginsconf->{$base}{'papid'};
    foreach my $coin ( keys %{$marginsconf} ) {
        if ( $base ne $coin ) {
            my $price = undef;
            my $papid = $marginsconf->{$coin}{'papid'};
            my $erc20 = $marginsconf->{$coin}{'erc20'};
            if ( !defined $erc20 ) { $erc20 = "0"; }
            if ( $coin eq "BTC" ) {
                my $cex_price = decode_json(binance_latest_price($base,$coin))->{'price'};
                $price = 1 / $cex_price;
            } else {
                my $coinprice = apipaprika($basepapid,$papid);
                if ( $coinprice ne "1" ) { $price = from_json($coinprice)->{'price'}; }
            }
            if ( ($erc20 eq "0") && (defined $price) ) {
                dex_setprice($base,$coin,$price);
            } elsif ( ($erc20 eq "1") && ($gasprice < $maxgasprice) && (defined $price) ) {
                dex_setprice($base,$coin,$price);
            } else {
                dex_deleteprice($base,$coin);
            }
        }
    }
} else {
    print "API not found\n";
}


if ( $cex eq "binance" ) {
    my $cex_bid_price_full = undef;
    my $cex_ask_price_full = undef;
    my $cex_bid_price_half = undef;
    my $cex_ask_price_half = undef;
    my $cex_bid_price_quarter = undef;
    my $cex_ask_price_quarter = undef;
    my $bidmargin = $marginsconf->{$base}{'bidmargin'};
    my $askmargin = $marginsconf->{$base}{'askmargin'};
    my $bidminmargin = $marginsconf->{$base}{'bidminmargin'};
    my $askminmargin = $marginsconf->{$base}{'askminmargin'};
    foreach my $coin ( "BTC", "ETH" ) {
        binance_cancelorders($base,$coin);
        my $cex_price = decode_json(binance_latest_price($base,$coin))->{'price'};
        my $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidminmargin));
        my $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askminmargin));
        my $binance_depth = decode_json(binance_depth($base,$coin));

        $cex_bid_price_full = calc_bestbidprice($binance_depth->{'bids'},$quantity*2,$coin);
        $cex_ask_price_full = calc_bestaskprice($binance_depth->{'asks'},$quantity*2,$coin);
        if ( ( !defined $cex_bid_price_full ) || ( $cex_bid_price_full > $maxbidprice ) ) { $cex_bid_price_full = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin)); }
        if ( ( !defined $cex_ask_price_full ) || ( $cex_ask_price_full < $minaskprice ) ) { $cex_ask_price_full = sprintf("%.8f", ($cex_price + $cex_price * $askmargin)); }
        binance_setprice($base,$coin,$cex_bid_price_full,$cex_ask_price_full,$quantity);

        $cex_bid_price_half = calc_bestbidprice($binance_depth->{'bids'},$quantity/2*1.5,$coin);
        $cex_ask_price_half = calc_bestaskprice($binance_depth->{'asks'},$quantity/2*1.5,$coin);
        if ( ( !defined $cex_bid_price_half ) || ( $cex_bid_price_half > $maxbidprice ) ) { $cex_bid_price_half = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin)); }
        if ( ( !defined $cex_ask_price_half ) || ( $cex_ask_price_half < $minaskprice ) ) { $cex_ask_price_half = sprintf("%.8f", ($cex_price + $cex_price * $askmargin)); }
        if ( $cex_ask_price_half > $cex_ask_price_full ) { $cex_ask_price_half = $cex_ask_price_full; }
        if ( $cex_bid_price_half < $cex_bid_price_full ) { $cex_bid_price_half = $cex_bid_price_full; }
        binance_setprice($base,$coin,$cex_bid_price_half,$cex_ask_price_half,$quantity/2);

        $cex_bid_price_quarter = calc_bestbidprice($binance_depth->{'bids'},$quantity/5*1.25,$coin);
        $cex_ask_price_quarter = calc_bestaskprice($binance_depth->{'asks'},$quantity/5*1.25,$coin);
        if ( ( !defined $cex_bid_price_quarter ) || ( $cex_bid_price_quarter > $maxbidprice ) ) { $cex_bid_price_quarter = sprintf("%.8f", ($cex_price - $cex_price * $bidminmargin)); }
        if ( ( !defined $cex_ask_price_quarter ) || ( $cex_ask_price_quarter < $minaskprice ) ) { $cex_ask_price_quarter = sprintf("%.8f", ($cex_price + $cex_price * $askminmargin)); }
        if ( $cex_ask_price_quarter > $cex_ask_price_half ) { $cex_ask_price_quarter = $cex_ask_price_half; }
        if ( $cex_bid_price_quarter < $cex_bid_price_half ) { $cex_bid_price_quarter = $cex_bid_price_half; }
        binance_setprice($base,$coin,$cex_bid_price_quarter,$cex_ask_price_quarter,$quantity/5);
    }
} elsif ( $cex eq "crex24" ) {
    my $bidmargin = $marginsconf->{$base}{'bidmargin'};
    my $askmargin = $marginsconf->{$base}{'askmargin'};
    foreach my $coin ( "BTC" ) {
        crex24_cancelorders($base,$coin);
        my $cex_price = decode_json(binance_latest_price($base,$coin))->{'price'};

        my $cex_bid_price = sprintf("%.7f", ($cex_price - $cex_price * $bidmargin));
        my $cex_ask_price = sprintf("%.7f", ($cex_price + $cex_price * $askmargin));
        crex24_setprice($base,$coin,$cex_bid_price,$cex_ask_price,$quantity);

        my $cex_bid_price_2 = sprintf("%.7f", ($cex_price - $cex_price * $bidmargin * 2));
        my $cex_ask_price_2 = sprintf("%.7f", ($cex_price + $cex_price * $askmargin * 2));
        crex24_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity*2);

        my $cex_bid_price_5 = sprintf("%.7f", ($cex_price - $cex_price * $bidmargin * 5));
        my $cex_ask_price_5 = sprintf("%.7f", ($cex_price + $cex_price * $askmargin * 5));
        crex24_setprice($base,$coin,$cex_bid_price_5,$cex_ask_price_5,$quantity*5);
    }
} else {
    print "CEX not found\n";
}

