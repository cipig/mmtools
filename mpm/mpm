#!/usr/bin/perl

use warnings;
no warnings 'experimental::smartmatch';
use LWP::UserAgent;
use LWP::Protocol::socks;
use JSON;
use JSON::RPC::Legacy::Client;
use File::Slurp qw(read_file);
use File::Basename;
use List::Util qw[min max];
use MIME::Base64;
use Digest::SHA qw(hmac_sha256_hex hmac_sha256_base64 hmac_sha512_base64);
use Digest::MD5 qw(md5_hex);
use DateTime;
use DateTime::Format::Strptime;
use Time::HiRes;
use Data::Dumper;

my $api = $ARGV[0];
my $base = $ARGV[1];
my $basepapid = $ARGV[2];
my $basegeckoid = $ARGV[2];
my $pubkey = $ARGV[3];
my $recvaddr = $ARGV[4];
my $recvZaddr = $ARGV[5];
my $cwd = dirname($0);
my $useragent = "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36";
my $timeout = 20;

my $binance_apikey = "";
my $binance_seckey = "";
my $mandala_apikey = "";
my $mandala_seckey = "";
my $crex24_apikey = "";
my $crex24_seckey = decode_base64("");
my $coinex_accessid = "";
my $coinex_seckey = "";
my $vcc_apikey = "";
my $vcc_seckey = "";
my $bitvavo_apikey = "";
my $bitvavo_seckey = "";
my $kucoin_apikey = "";
my $kucoin_seckey = "";
my $kucoin_passphrase = "";


sub paprika_latest_price {
    my $url = "https://api.coinpaprika.com/v1/price-converter?base_currency_id=".$_[1]."&quote_currency_id=".$_[0]."&amount=1";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub gecko_latest_price {
    my $url = "https://api.coingecko.com/api/v3/simple/price?ids=".$_[0]."&vs_currencies=btc,usd,cad,sgd,chf,cny,nzd&include_24hr_change=true";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            #print Dumper($resp->content);
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            #print Dumper($resp->content);
            return 1;
        }
}


sub safetrade_latest_price {
    my $url = "https://safe.trade/api/v2/peatio/public/markets/".$_[0]."/tickers";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub komodolive_latest_price {
    my $coin = $_[0];
    my $url = "https://myprice.cipig.net:1717/api/v1/ticker_infos";
    my $ua = LWP::UserAgent->new;
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => $url);
    #$req->content_type('application/x-www-form-urlencoded');
    $req->content_type('application/json');

    #$command = '{"expire_at":"600","ticker": "'.$coin.'"}';
    $command = '{"ticker": "'.$coin.'"}';
    $req->content($command);
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            #print Dumper($resp->content);
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub komodolive_usdrates {
    my $url = "https://rates.komodo.live/api/v1/usd_rates";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub southxchange_latest_price {
    my $url = "https://www.southxchange.com/api/v4/price/".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub freiexchange_latest_price {
    my $url = "https://api.freiexchange.com/public/ticker";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub smartfi_latest_price {
    my $url = "https://node1.smartfi.com/market/get-market-summary";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    #$ua->proxy([qw(http https)] => 'socks://127.0.0.1:9050');
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub dex_ticker_24h {
    my $url = "https://dexapi.cipig.net/public/ticker_24h.php?market=".$_[0]."-".$_[1];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub paprika_price {
    my $base = $_[0];
    my $rel = $_[1];
    my $amount = $_[2];
    my $url = "https://api.coinpaprika.com/v1/price-converter?base_currency_id=".$base."&quote_currency_id=".$rel."&amount=".$amount;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
        }
}


sub binance_latest_price {
    my $symbol = $_[0];
    my $url = "https://api.binance.com/api/v3/ticker/price?symbol=".$symbol;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub binance_book_price {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.binance.com/api/v3/ticker/bookTicker?symbol=".$base.$coin;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub kucoin_latest_price {
    my $url = "https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return decode_json($resp->content)->{'data'};
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub kucoin_book_price {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=".$base."-".$coin;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return decode_json($resp->content)->{'data'};
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub bitvavo_book_price {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.bitvavo.com/v2/ticker/book?market=".$base."-".$coin;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub binance_kline {
    my $base = $_[0];
    my $coin = $_[1];
    my $interval = $_[2];
    my $limit = $_[3];
    my $url = "https://api.binance.com/api/v3/klines?symbol=".$base.$coin."&interval=".$interval."&limit=".$limit;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub coinex_latest_price {
    my $url = "https://api.coinex.com/v1/market/ticker?market=".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub hitbtc_latest_price {
    my $url = "https://api.hitbtc.com/api/2/public/ticker/".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub bithumb_latest_price {
    my $url = "https://global-openapi.bithumb.pro/openapi/v1/spot/ticker?symbol=".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub binance_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.binance.com/api/v3/depth?symbol=".$base.$coin."&limit=100";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub kucoin_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.kucoin.com/api/v1/market/orderbook/level2_100?symbol=".$base."-".$coin;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return decode_json($resp->content)->{'data'};
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub bitvavo_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.bitvavo.com/v2/".$base."-".$coin."/book";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub bittrex_latest_price {
    my $url = "https://api.bittrex.com/v3/markets/".$_[0]."/ticker";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub bittrex_summary {
    my $url = "https://api.bittrex.com/v3/markets/".$_[0]."/summary";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub crex24_latest_price {
    my $url = "https://api.crex24.com/v2/public/tickers?instrument=".$_[0];
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub crex24_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.crex24.com/v2/public/orderBook?instrument=".$base."-".$coin;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub vcc_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://vcc.exchange/api/v2/orderbook/".$base."_".$coin."?depth=20";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return decode_json($resp->content)->{'data'};
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
        }
}


sub coinex_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.coinex.com/v1/market/depth?market=".$base.$coin."&limit=10&merge=0";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return decode_json($resp->content)->{'data'};
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub binance_getorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $command = "symbol=".$base.$coin."&recvWindow=15000&timestamp=".time()*1000;
    my $signature = hmac_sha256_hex($command, $binance_seckey);
    my $url = "https://api.binance.com/api/v3/openOrders?".$command."&signature=".$signature;

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('X-MBX-APIKEY' => $binance_apikey);
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub binance_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(DELETE => 'https://api.binance.com/api/v3/order');
    $req->header('X-MBX-APIKEY' => $binance_apikey);

    my $binance_orders = binance_getorders($base,$coin);
    if ( $binance_orders ne "1" ) {
        my $orders = decode_json($binance_orders);
        foreach my $order( @$orders ) {
            my $orderid = $order->{'clientOrderId'};
            $command = "symbol=".$base.$coin."&origClientOrderId=".$orderid."&recvWindow=15000&timestamp=".time()*1000;
            $signature = hmac_sha256_hex($command, $binance_seckey);
            $body = $command."&signature=".$signature;
            $req->content($body);
            $resp = $ua->request($req);
            #print $resp->content."\n";
        }
    }
}


sub kucoin_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];
    my $tonce = time()*1000;
    my $endpoint = "/api/v1/orders?symbol=".$base."-".$coin;
    my $url = "https://api.kucoin.com".$endpoint;

    my $prehash = $tonce."DELETE".$endpoint; # {timestamp+method+endpoint+body}
    my $apisign = hmac_sha256_base64($prehash, $kucoin_seckey);
    while (length($apisign) % 4) {
        $apisign .= '=';
    }
    my $passphrase = hmac_sha256_base64($kucoin_passphrase, $kucoin_seckey); #  Encrypt passphrase with HMAC-sha256 via API-Secret --> Encode contents by base64 before you pass the request
    while (length($passphrase) % 4) {
        $passphrase .= '=';
    }

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(DELETE => $url);
    $req->header('KC-API-KEY-VERSION' => '2');
    $req->header('KC-API-KEY' => $kucoin_apikey);
    $req->header('KC-API-SIGN' => $apisign);
    $req->header('KC-API-TIMESTAMP' => $tonce);
    $req->header('KC-API-PASSPHRASE' => $passphrase);
    $req->header('content-type' => 'application/json');
    $req->content();
    $resp = $ua->request($req);
    #print $resp->content;
}


sub mandala_getorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $command = "symbol=".$base."_".$coin."&type=1&recvWindow=15000&timestamp=".time()*1000;
    my $signature = hmac_sha256_hex($command, $mandala_seckey);
    my $url = "https://trade.mandala.exchange/open/v1/orders?".$command."&signature=".$signature;

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('X-MBX-APIKEY' => $mandala_apikey);
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub mandala_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(POST => 'https://trade.mandala.exchange/open/v1/orders/cancel');
    $req->header('X-MBX-APIKEY' => $mandala_apikey);
    $req->header('content-type' => 'application/x-www-form-urlencoded');

    my $mandala_orders = mandala_getorders($base,$coin);
    if ( $mandala_orders ne "1" ) {
        my $orders = decode_json($mandala_orders)->{'data'}{'list'};
        foreach my $order( @$orders ) {
            my $orderid = $order->{'orderId'};
            $command = "orderId=".$orderid."&recvWindow=15000&timestamp=".time()*1000;
            $signature = hmac_sha256_hex($command, $mandala_seckey);
            $body = $command."&signature=".$signature;
            $req->content($body);
            $resp = $ua->request($req);
            #print $resp->content."\n";
        }
    }
}


sub bitvavo_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $timestamp = time()*1000;
    my $url = "https://api.bitvavo.com/v2/orders";
    my $params = "?market=".$base."-".$coin;
    my $command = $timestamp."DELETE/v2/orders".$params;
    my $signature = hmac_sha256_hex($command, $bitvavo_seckey);
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(DELETE => $url.$params);
    $req->header('BITVAVO-ACCESS-KEY' => $bitvavo_apikey);
    $req->header('BITVAVO-ACCESS-SIGNATURE' => $signature);
    $req->header('BITVAVO-ACCESS-TIMESTAMP' => $timestamp);
    $req->header('content-type' => 'application/json');
    $req->content();
    $resp = $ua->request($req);
    #print $resp->content."\n";
}


sub coinex_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];
    my $tonce = time()*1000;
    my $url = "https://api.coinex.com/v1/order/pending?";
    my $params = "access_id=".$coinex_accessid."&account_id=0&market=".$base.$coin."&tonce=".$tonce;
    my $authorization = uc(md5_hex($params."&secret_key=".$coinex_seckey));

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(DELETE => $url.$params);
    $req->header('authorization' => $authorization);
    $req->header('content-type' => 'application/json');
    $req->content();
    $resp = $ua->request($req);
    #print $resp->content;
}


sub vcc_getorders {
    my $base = lc($_[1]);
    my $coin = lc($_[0]);
    my $tonce = time()*1000;
    my $url = "https://vcc.exchange/api/v2/orders/open";
    my $params = '?currency='.$base.'&coin='.$coin;
    my $payload = "GET api/v2/orders/open".$params;
    my $signature = hmac_sha256_hex($payload, $vcc_seckey);

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(GET => $url.$params);
    $req->header('Authorization' => 'Bearer '.$vcc_apikey);
    $req->header('timestamp' => $tonce);
    $req->header('signature' => $signature);
    $req->content();
    $resp = $ua->request($req);
    return $resp->content;
}


sub vcc_cancelorder {
    my $order_id = $_[0];
    my $tonce = time()*1000;
    my $url = "https://vcc.exchange/api/v2/orders/".$order_id."/cancel";
    my $payload = "PUT api/v2/orders/".$order_id."/cancel";
    my $signature = hmac_sha256_hex($payload, $vcc_seckey);

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(PUT => $url);
    $req->header('Authorization' => 'Bearer '.$vcc_apikey);
    $req->header('timestamp' => $tonce);
    $req->header('signature' => $signature);
    $req->content();
    $resp = $ua->request($req);
    #print $resp->content;
}


sub vcc_cancelorders {
    my $base = lc($_[1]);
    my $coin = lc($_[0]);
    my $orders = decode_json(vcc_getorders($coin,$base));
    for my $order( @{$orders->{data}{data}} ){
        vcc_cancelorder($order->{id});
    }
}


sub vcc_cancelallorders {
    my $tonce = time()*1000;
    my $url = "https://vcc.exchange/api/v2/orders/cancel-all";
    my $payload = "PUT api/v2/orders/cancel-all";
    my $signature = hmac_sha256_hex($payload, $vcc_seckey);

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(PUT => $url);
    $req->header('Authorization' => 'Bearer '.$vcc_apikey);
    $req->header('timestamp' => $tonce);
    $req->header('signature' => $signature);
    $req->content();
    $resp = $ua->request($req);
    #print $resp->content;
}


sub crex24_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];
    my $urlpath = "/v2/trading/cancelOrdersByInstrument";
    my $nonce = $_[2];
    my $body = '{"instruments":["'.$base.'-'.$coin.'"]}';
    my $command = $urlpath . $nonce . $body;
    my $signature = hmac_sha512_base64($command,$crex24_seckey);
    while (length($signature) % 4) {
        $signature .= '=';
    }

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    $req = HTTP::Request->new(POST => 'https://api.crex24.com/v2/trading/cancelOrdersByInstrument');
    $req->header('X-CREX24-API-KEY' => $crex24_apikey,
                 'X-CREX24-API-NONCE' => $nonce,
                 'X-CREX24-API-SIGN' => $signature);

    $req->content($body);
    my $resp = $ua->request($req);
    #print $resp->content."\n";
}


sub binance_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = undef;
    my $ask = undef;
    if (( $coin eq "BUSD" ) || ( $coin eq "USDT" )) {
        $bid = sprintf("%.4f",$_[2]);
        $ask = sprintf("%.4f",$_[3]);
    } elsif ( $coin eq "ETH" ) {
        $bid = sprintf("%.7f",$_[2]);
        $ask = sprintf("%.7f",$_[3]);
    } else {
        $bid = sprintf("%.8f",$_[2]);
        $ask = sprintf("%.8f",$_[3]);
    }
    my $quantity = sprintf("%u",$_[4]);

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'https://api.binance.com/api/v3/order');
    $req->header('X-MBX-APIKEY' => $binance_apikey);

    print "$base/$coin size ".sprintf("%04d",$quantity);

    if ( defined $bid ) {
        my $command = "symbol=".$base.$coin."&side=BUY&type=LIMIT_MAKER&newOrderRespType=RESULT&quantity=".$quantity."&price=".$bid."&newClientOrderId=buy".$coin.$base.$quantity."&recvWindow=15000&timestamp=".time()*1000;
        my $signature = hmac_sha256_hex($command, $binance_seckey);
        my $body = $command."&signature=".$signature;
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " bid ".$bid;
        } else {
            print " bid ".$resp->content;
        }
    }

    if ( defined $ask ) {
	my $command = "symbol=".$base.$coin."&side=SELL&type=LIMIT_MAKER&newOrderRespType=RESULT&quantity=".$quantity."&price=".$ask."&newClientOrderId=sell".$coin.$base.$quantity."&recvWindow=15000&timestamp=".time()*1000;
	my $signature = hmac_sha256_hex($command, $binance_seckey);
        my $body = $command."&signature=".$signature;
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " ask ".$ask."\n";
        } else {
            print " ask ".$resp->content."\n";
        }
    }
}


sub kucoin_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = undef;
    my $ask = undef;
    if (( $coin eq "BUSD" ) || ( $coin eq "USDT" )) {
        $bid = sprintf("%.4f",$_[2]);
        $ask = sprintf("%.4f",$_[3]);
    } else {
        $bid = sprintf("%.8f",$_[2]);
        $ask = sprintf("%.8f",$_[3]);
    }
    my $quantity = sprintf("%u",$_[4]);

    my $endpoint = "/api/v1/orders";
    my $url = "https://api.kucoin.com".$endpoint;

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'https://api.kucoin.com/api/v1/orders');

    print "$base/$coin size ".sprintf("%04d",$quantity);

    if ( defined $bid ) {
        my $tonce = time()*1000;
        my $body = '{"clientOid":"buy'.$base.$coin.$quantity.'","side":"buy","symbol":"'.$base.'-'.$coin.'","type":"limit","price":'.$bid.',"size":'.$quantity.'}';
        my $prehash = $tonce."POST".$endpoint.$body; # {timestamp+method+endpoint+body}
        my $apisign = hmac_sha256_base64($prehash, $kucoin_seckey);
        while (length($apisign) % 4) {
            $apisign .= '=';
        }
        my $passphrase = hmac_sha256_base64($kucoin_passphrase, $kucoin_seckey); #  Encrypt passphrase with HMAC-sha256 via API-Secret --> Encode contents by base64 before you pass the request
        while (length($passphrase) % 4) {
            $passphrase .= '=';
        }
        $req->header('KC-API-KEY-VERSION' => '2');
        $req->header('KC-API-KEY' => $kucoin_apikey);
        $req->header('KC-API-SIGN' => $apisign);
        $req->header('KC-API-TIMESTAMP' => $tonce);
        $req->header('KC-API-PASSPHRASE' => $passphrase);
        $req->header('content-type' => 'application/json');

        $req->content($body);
        my $resp = $ua->request($req);
        my $resp_code = decode_json($resp->content)->{'code'};
        if ($resp_code eq "200000") {
            print " bid ".$bid;
        } else {
            print " bid ".decode_json($resp->content)->{'msg'};
        }

    }

    if ( defined $ask ) {
        my $tonce = time()*1000;
        my $body = '{"clientOid":"sell'.$base.$coin.$quantity.'","side":"sell","symbol":"'.$base.'-'.$coin.'","type":"limit","price":'.$ask.',"size":'.$quantity.'}';
        my $prehash = $tonce."POST".$endpoint.$body; # {timestamp+method+endpoint+body}
        my $apisign = hmac_sha256_base64($prehash, $kucoin_seckey);
        while (length($apisign) % 4) {
            $apisign .= '=';
        }
        my $passphrase = hmac_sha256_base64($kucoin_passphrase, $kucoin_seckey); #  Encrypt passphrase with HMAC-sha256 via API-Secret --> Encode contents by base64 before you pass the request
        while (length($passphrase) % 4) {
            $passphrase .= '=';
        }
        $req->header('KC-API-KEY-VERSION' => '2');
        $req->header('KC-API-KEY' => $kucoin_apikey);
        $req->header('KC-API-SIGN' => $apisign);
        $req->header('KC-API-TIMESTAMP' => $tonce);
        $req->header('KC-API-PASSPHRASE' => $passphrase);
        $req->header('content-type' => 'application/json');

        $req->content($body);
        my $resp = $ua->request($req);
        my $resp_code = decode_json($resp->content)->{'code'};
        if ($resp_code eq "200000") {
            print " ask ".$ask."\n";
        } else {
            print " ask ".decode_json($resp->content)->{'msg'}."\n";
        }

    }
}


sub mandala_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = undef;
    my $ask = undef;
    if (( $coin eq "BUSD" ) || ( $coin eq "USDT" )) {
        $bid = sprintf("%.4f",$_[2]);
        $ask = sprintf("%.4f",$_[3]);
    } elsif ( $coin eq "ETH" ) {
        $bid = sprintf("%.7f",$_[2]);
        $ask = sprintf("%.7f",$_[3]);
    } else {
        $bid = sprintf("%.8f",$_[2]);
        $ask = sprintf("%.8f",$_[3]);
    }
    my $quantity = sprintf("%u",$_[4]);

    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'https://trade.mandala.exchange/open/v1/orders');
    $req->header('X-MBX-APIKEY' => $mandala_apikey);
    $req->header('content-type' => 'application/x-www-form-urlencoded');

    print "$base/$coin size ".sprintf("%04d",$quantity);

    if ( defined $bid ) {
        my $command = "symbol=".$base."_".$coin."&side=0&type=1&quantity=".$quantity."&price=".$bid."&clientId=buy".$coin.$base.$quantity."&recvWindow=15000&timestamp=".time()*1000;
        my $signature = hmac_sha256_hex($command, $mandala_seckey);
        my $body = $command."&signature=".$signature;
        $req->content($body);
        my $resp = $ua->request($req);
        my $resp_code = decode_json($resp->content)->{'code'};
        if ($resp_code eq "0") {
            print " bid ".$bid;
        } else {
            print " bid ".decode_json($resp->content)->{'msg'};
        }
    }

    if ( defined $ask ) {
        my $command = "symbol=".$base."_".$coin."&side=1&type=1&quantity=".$quantity."&price=".$ask."&clientId=sell".$coin.$base.$quantity."&recvWindow=15000&timestamp=".time()*1000;
        my $signature = hmac_sha256_hex($command, $mandala_seckey);
        my $body = $command."&signature=".$signature;
        $req->content($body);
        my $resp = $ua->request($req);
        my $resp_code = decode_json($resp->content)->{'code'};
        if ($resp_code eq "0") {
            print " ask ".$ask."\n";
        } else {
            print " ask ".decode_json($resp->content)->{'msg'}."\n";
        }
    }
}


sub bitvavo_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = $_[2];
    my $ask = $_[3];
    if ( ($ask < 1) && ($bid < 1) ) {
        $bid = sprintf("%.5f",$_[2]);
        $ask = sprintf("%.5f",$_[3]);
    } else {
        $bid = sprintf("%.4f",$_[2]);
        $ask = sprintf("%.4f",$_[3]);
    }
    my $quantity = sprintf("%u",$_[4]);

    my $timestamp = time()*1000;
    my $url = "https://api.bitvavo.com/v2/order";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => $url);

    print "$base/$coin size ".sprintf("%04d",$quantity);

    if ( defined $bid ) {
        my $body = '{"market":"'.$base.'-'.$coin.'","side":"buy","price":"'.$bid.'","amount":"'.$quantity.'","orderType":"limit","postOnly":true,"responseRequired":false}';
        my $command = $timestamp."POST/v2/order".$body;
        my $signature = hmac_sha256_hex($command, $bitvavo_seckey);
        $req->header('BITVAVO-ACCESS-KEY' => $bitvavo_apikey);
        $req->header('BITVAVO-ACCESS-SIGNATURE' => $signature);
        $req->header('BITVAVO-ACCESS-TIMESTAMP' => $timestamp);
        $req->header('content-type' => 'application/json');
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " bid ".$bid;
        } else {
            print " bid 0.00000";
            print " ".$resp->content;
        }
    }

    if ( defined $ask ) {
        my $body = '{"market":"'.$base.'-'.$coin.'","side":"sell","price":"'.$ask.'","amount":"'.$quantity.'","orderType":"limit","postOnly":true,"responseRequired":false}';
        my $command = $timestamp."POST/v2/order".$body;
        my $signature = hmac_sha256_hex($command, $bitvavo_seckey);
        $req->header('BITVAVO-ACCESS-KEY' => $bitvavo_apikey);
        $req->header('BITVAVO-ACCESS-SIGNATURE' => $signature);
        $req->header('BITVAVO-ACCESS-TIMESTAMP' => $timestamp);
        $req->header('content-type' => 'application/json');
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " ask ".$ask."\n";
        } else {
            print " ask 0.00000\n";
            print " ".$resp->content."\n";
        }
    }
}


sub crex24_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = $_[2];
    my $ask = $_[3];
    my $quantity = sprintf("%u",$_[4]);
    my $nonce = $_[5];
    my $urlpath = "/v2/trading/placeOrder";

    print "$base/$coin size ".sprintf("%03d",$quantity);

    if ( defined $bid ) {
        my $body = '{"instrument":"'.$base.'-'.$coin.'","side":"buy","volume":'.$quantity.',"price":'.$bid.'}';
        my $command = $urlpath . $nonce . $body;
        my $signature = hmac_sha512_base64($command,$crex24_seckey);
        while (length($signature) % 4) {
            $signature .= '=';
        }
        my $ua = LWP::UserAgent->new;
        $ua->agent($useragent);
        $ua->timeout($timeout);
        $req = HTTP::Request->new(POST => 'https://api.crex24.com/v2/trading/placeOrder');
        $req->header('X-CREX24-API-KEY' => $crex24_apikey,
                     'X-CREX24-API-NONCE' => $nonce,
                     'X-CREX24-API-SIGN' => $signature);
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " bid ".$bid;
        } else {
            print " bid 0.0000000";
            print " ".$resp->content;
        }
    }

    if ( defined $ask ) {
        $nonce = $nonce+1;
        my $body = '{"instrument":"'.$base.'-'.$coin.'","side":"sell","volume":'.$quantity.',"price":'.$ask.'}';
        my $command = $urlpath . $nonce . $body;
        my $signature = hmac_sha512_base64($command,$crex24_seckey);
        while (length($signature) % 4) {
            $signature .= '=';
        }
        my $ua = LWP::UserAgent->new;
        $ua->agent($useragent);
        $ua->timeout($timeout);
        $req = HTTP::Request->new(POST => 'https://api.crex24.com/v2/trading/placeOrder');
        $req->header('X-CREX24-API-KEY' => $crex24_apikey,
                     'X-CREX24-API-NONCE' => $nonce,
                     'X-CREX24-API-SIGN' => $signature);
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " ask ".$ask."\n";
        } else {
            print " ask 0.0000000\n";
            print " ".$resp->content."\n";
        }
    }
}


sub vcc_setprice {
    my $base = lc($_[1]);
    my $coin = lc($_[0]);
    my $bid = $_[2];
    my $ask = $_[3];
    my $quantity = sprintf("%u",$_[4]);
    my $url = "https://vcc.exchange/api/v2/orders";

    print "$_[0]/$_[1] size ".sprintf("%03d",$quantity);

    if ( defined $bid ) {
        my $tonce = time()*1000;
        my $params = '?currency='.$base.'&coin='.$coin.'&trade_type=buy&type=limit&quantity='.$quantity.'&price='.$bid;
        my $payload = "POST api/v2/orders".$params;
        my $signature = hmac_sha256_hex($payload, $vcc_seckey);
        my $ua = LWP::UserAgent->new;
        $ua->agent($useragent);
        $ua->timeout($timeout);
        $req = HTTP::Request->new(POST => $url.$params);
        $req->header('Authorization' => 'Bearer '.$vcc_apikey);
        $req->header('timestamp' => $tonce);
        $req->header('signature' => $signature);
        $req->header('content-type' => 'application/json');
        $req->content();
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " bid ".$bid;
        } else {
            print " bid 0.00000000";
            #print " ".$resp->content;
        }
    }

    if ( defined $ask ) {
        my $tonce = time()*1000;
        my $params = '?currency='.$base.'&coin='.$coin.'&trade_type=sell&type=limit&quantity='.$quantity.'&price='.$ask;
        my $payload = "POST api/v2/orders".$params;
        my $signature = hmac_sha256_hex($payload, $vcc_seckey);
        my $ua = LWP::UserAgent->new;
        $ua->agent($useragent);
        $ua->timeout($timeout);
        $req = HTTP::Request->new(POST => $url.$params);
        $req->header('Authorization' => 'Bearer '.$vcc_apikey);
        $req->header('timestamp' => $tonce);
        $req->header('signature' => $signature);
        $req->header('content-type' => 'application/json');
        $req->content();
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " ask ".$ask."\n";
        } else {
            print " ask 0.00000000\n";
            #print " ".$resp->content."\n";
        }
    }
}


sub coinex_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = undef;
    my $ask = undef;
    if ( $coin eq "USDT" ) {
        $bid = sprintf("%.4f",$_[2]);
        $ask = sprintf("%.4f",$_[3]);
    } else {
        $bid = sprintf("%.8f",$_[2]);
        $ask = sprintf("%.8f",$_[3]);
    }
    my $quantity = sprintf("%u",$_[4]);
    my $url = "https://api.coinex.com/v1/order/limit";

    print "$base/$coin size ".sprintf("%03d",$quantity);

    if ( defined $bid ) {
        my $tonce = time()*1000;
        my $body = '{ "access_id":"'.$coinex_accessid.'","amount":"'.$quantity.'","price":"'.$bid.'","type":"buy","market":"'.$base.$coin.'","tonce":'.$tonce.' }';
        my $signtext = "access_id=".$coinex_accessid."&amount=".$quantity."&market=".$base.$coin."&price=".$bid."&tonce=".$tonce."&type=buy&secret_key=".$coinex_seckey;
        my $authorization = uc(md5_hex($signtext));

        my $ua = LWP::UserAgent->new;
        $ua->agent($useragent);
        $ua->timeout($timeout);
        $req = HTTP::Request->new(POST => $url);
        $req->header('authorization' => $authorization);
        $req->header('content-type' => 'application/json');
        $req->content($body);
        $resp = $ua->request($req);
        my $code = decode_json($resp->content)->{'code'};
        if ($code eq "0") {
            print " bid ".$bid;
        } else {
            print " bid 0.00000000";
            print " ".$resp->content;
        }
    }

    if ( defined $ask ) {
        my $tonce = time()*1000;
        my $body = '{ "access_id":"'.$coinex_accessid.'","amount":"'.$quantity.'","price":"'.$ask.'","type":"sell","market":"'.$base.$coin.'","tonce":'.$tonce.' }';
        my $signtext = "access_id=".$coinex_accessid."&amount=".$quantity."&market=".$base.$coin."&price=".$ask."&tonce=".$tonce."&type=sell&secret_key=".$coinex_seckey;
        my $authorization = uc(md5_hex($signtext));

        my $ua = LWP::UserAgent->new;
        $ua->agent($useragent);
        $ua->timeout($timeout);
        $req = HTTP::Request->new(POST => $url);
        $req->header('authorization' => $authorization);
        $req->header('content-type' => 'application/json');
        $req->content($body);
        $resp = $ua->request($req);
        my $code = decode_json($resp->content)->{'code'};
        if ($code eq "0") {
            print " ask ".$ask."\n";
        } else {
            print " ask 0.00000000\n";
            print " ".$resp->content."\n";
        }
    }
}


sub dex_setprice {
    my $base = $_[0];
    my $rel = $_[1];
    my $bid1 = $_[2];
    my $ask1 = $_[3];
    my $bid2 = $_[4];
    my $ask2 = $_[5];
    my $maxbidvolume = $_[6];
    my $minbidvolume = $_[7];
    my $maxaskvolume = $_[8];
    my $minaskvolume = $_[9];
    my $bidmargin1 = $_[10];
    my $askmargin1 = $_[11];
    my $bidmargin2 = $_[12];
    my $askmargin2 = $_[13];
    my $coinusdprice = $_[14];
    my $rel_mintradevol = $_[15];
    my $base_mintradevol = $_[16];
    my $rel_balance = $_[17];
    my $base_balance = $_[18];

    my $ua = LWP::UserAgent->new;
    #$ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    print "$rel/$base ";
    if ( defined $ask1 ) {
        my $command1 = undef;
        my $command2 = undef;
        my $askvolume1 = 0;
        my $askvolume2 = 0;
        if ( defined $maxaskvolume ) {
            $askvolume1 = $maxaskvolume;
            if ($askvolume1 > $rel_balance*0.8) { $askvolume1 = $rel_balance*0.8; }
            #$askvolume1 = $maxaskvolume*0.33;
            #$askvolume2 = $maxaskvolume*0.66;
            #if ($askvolume1 > $rel_balance*0.33) { $askvolume1 = $rel_balance*0.33; }
            #if ($askvolume2 > $rel_balance*0.66) { $askvolume2 = $rel_balance*0.66; }
        } else {
            $askvolume1 = $rel_balance*0.8;
            #$askvolume1 = $rel_balance*0.33;
            #$askvolume2 = $rel_balance*0.66;
        }

        if ( $askvolume1 > 0 ) {
            if (defined $minaskvolume) {
                my $minaskvolume1 = $minaskvolume * (1 - $askmargin1);
                #my $minaskvolume2 = $minaskvolume * (1 - $askmargin2);
                if ($minaskvolume1 < $rel_mintradevol) { $minaskvolume1 = $rel_mintradevol; }
                #if ($minaskvolume2 < $rel_mintradevol) { $minaskvolume2 = $rel_mintradevol; }
                if ($minaskvolume1 < $base_mintradevol/$ask1) { $minaskvolume1 = $base_mintradevol/$ask1*1.1; }
                #if ($minaskvolume2 < $base_mintradevol/$ask2) { $minaskvolume2 = $base_mintradevol/$ask2*1.1; }
                $command1 = '{"userpass":"'.$userpass.'","method":"setprice","save_in_history":false,"base":"'.$rel.'","rel":"'.$base.'","price":'.$ask1.',"volume":'.$askvolume1.',"min_volume":'.$minaskvolume1.'}';
                #$command2 = '{"userpass":"'.$userpass.'","method":"setprice","save_in_history":false,"base":"'.$rel.'","rel":"'.$base.'","price":'.$ask2.',"volume":'.$askvolume2.',"min_volume":'.$minaskvolume2.',"cancel_previous":false}';
            } else {
                $command1 = '{"userpass":"'.$userpass.'","method":"setprice","save_in_history":false,"base":"'.$rel.'","rel":"'.$base.'","price":'.$ask1.',"volume":'.$askvolume1.'}';
                #$command2 = '{"userpass":"'.$userpass.'","method":"setprice","save_in_history":false,"base":"'.$rel.'","rel":"'.$base.'","price":'.$ask2.',"volume":'.$askvolume2.',"cancel_previous":false}';
            }

            $req->content($command1);
            my $resp1 = $ua->request($req);
            if ($resp1->is_success) {
                print "ask1 ".sprintf("%.10f",$ask1)." ";
            } else {
                my $askerror1 = eval {from_json($resp1->content)->{'error'}};
                if ($@) { print "unknown error $@"; } else { print $askerror1." "; }
            }

            #$req->content($command2);
            #my $resp2 = $ua->request($req);
            #my $askerror2 = from_json($resp2->content)->{'error'};
            #if ( defined $askerror2 ) { print $askerror2." "; } else { print "ask2 ".sprintf("%.10f",$ask2)." "; }
        } else {
            $command1 = '{"userpass":"'.$userpass.'","method":"cancel_all_orders","cancel_by":{"type":"Pair","data":{"base":"'.$rel.'","rel":"'.$base.'"}}}';
            $req->content($command1);
            my $resp = $ua->request($req);
            if ($resp->is_success) {
                print "ask1 deleted ";
            } else {
                my $askerror1 = eval {from_json($resp->content)->{'error'}};
                if ($@) { print "unknown error $@"; } else { print $askerror1." "; }
            }
        }
    }

    if ( defined $bid1 ) {
        my $command1 = undef;
        my $command2 = undef;
        my $bidvolume1 = 0;
        my $bidvolume2 = 0;
        if ( defined $maxbidvolume ) {
            $bidvolume1 = $maxbidvolume;
            if ($bidvolume1 > $base_balance*0.8) { $bidvolume1 = $base_balance*0.8; }
            #$bidvolume1 = $maxbidvolume*0.33;
            #$bidvolume2 = $maxbidvolume*0.66;
            #if ($bidvolume1 > $base_balance*0.33) { $bidvolume1 = $base_balance*0.33; }
            #if ($bidvolume2 > $base_balance*0.66) { $bidvolume2 = $base_balance*0.66; }
        } else {
            $bidvolume1 = $base_balance*0.8;
            #$bidvolume1 = $base_balance*0.33;
            #$bidvolume2 = $base_balance*0.66;
        }

        if ( $bidvolume1 > 0 ) {
            if ( defined $minbidvolume ) {
                my $minbidvolume1 = $minbidvolume * (1 - $bidmargin1);
                #my $minbidvolume2 = $minbidvolume * (1 - $bidmargin2);
                if ($minbidvolume1 < $base_mintradevol) { $minbidvolume1 = $base_mintradevol; }
                #if ($minbidvolume2 < $base_mintradevol) { $minbidvolume2 = $base_mintradevol; }
                $command1 = '{"userpass":"'.$userpass.'","method":"setprice","save_in_history":false,"base":"'.$base.'","rel":"'.$rel.'","price":'.$bid1.',"volume":'.$bidvolume1.',"min_volume":'.$minbidvolume1.'}';
                #$command2 = '{"userpass":"'.$userpass.'","method":"setprice","save_in_history":false,"base":"'.$base.'","rel":"'.$rel.'","price":'.$bid2.',"volume":'.$bidvolume2.',"min_volume":'.$minbidvolume2.',"cancel_previous":false}';
            } else {
                $command1 = '{"userpass":"'.$userpass.'","method":"setprice","save_in_history":false,"base":"'.$base.'","rel":"'.$rel.'","price":'.$bid1.',"volume":'.$bidvolume1.'}';
                #$command2 = '{"userpass":"'.$userpass.'","method":"setprice","save_in_history":false,"base":"'.$base.'","rel":"'.$rel.'","price":'.$bid2.',"volume":'.$bidvolume2.',"cancel_previous":false}';
            }

            $req->content($command1);
            $resp1 = $ua->request($req);
            if ($resp1->is_success) {
                print "bid1 ".sprintf("%.10f",1/$bid1)." ";
            } else {
                my $biderror1 = eval {from_json($resp1->content)->{'error'}};
                if ($@) { print "unknown error $@"; } else { print $biderror1." "; }
            }

            #$req->content($command2);
            #$resp2 = $ua->request($req);
            #my $biderror2 = from_json($resp2->content)->{'error'};
            #if ( defined $biderror2 ) { print $biderror2; } else { print "bid2 ".sprintf("%.10f",1/$bid2); }
        } else {
            $command1 = '{"userpass":"'.$userpass.'","method":"cancel_all_orders","cancel_by":{"type":"Pair","data":{"base":"'.$base.'","rel":"'.$rel.'"}}}';
            $req->content($command1);
            my $resp = $ua->request($req);
            if ($resp->is_success) {
                print "bid1 deleted ";
            } else {
                my $biderror1 = eval {from_json($resp->content)->{'error'}};
                if ($@) { print "unknown error $@"; } else { print $biderror1." "; }
            }
        }
    }
    print " balance_in_usd: ".sprintf("%.2f",$rel_balance*$coinusdprice)."\n";
}


sub dexp2p_setprice {
    my $base = $_[0];
    my $rel = $_[1];
    my $base_price = $_[2];
    my $rel_price = $_[3];
    my $base_balance = $_[4];
    my $rel_balance = $_[5];

    if ( defined $marginsconf->{$_[1]}{'askmargin'} ) {
        $ask = sprintf("%.8f", $base_price + $base_price * $marginsconf->{$_[1]}{'askmargin'});
    }
    if ( defined $marginsconf->{$_[1]}{'bidmargin'} ) {
        $bid = sprintf("%.8f", $rel_price + $rel_price * $marginsconf->{$_[1]}{'bidmargin'});
    }

    my $client = new JSON::RPC::Legacy::Client;
    $client->ua->credentials('localhost:10591', 'jsonrpc', 'dexp2p' => 'KeWt2phRPXUPGX');
    my $uri = 'http://localhost:10591/';

    print "$rel/$base ";
    if ( defined $ask ) {
        my $obj = { method => 'DEX_broadcast', params => ['hello','0',$rel,$base,$pubkey,''.$rel_balance,''.$ask] };
        my $res = $client->call( $uri, $obj );
        if ($res){
           if ($res->is_error) { print "Error : ", Dumper($res->error_message); }
           #else { print Dumper($res->result); }
           else { print "ask ".sprintf("%.8f",$ask/$rel_balance)." "; }
        } else {
           print $client->status_line;
        }
    }

    if ( defined $bid ) {
        my $obj = { method => 'DEX_broadcast', params => ['hello','0',$base,$rel,$pubkey,''.$base_balance,''.$bid] };
        my $res = $client->call( $uri, $obj );
        if ($res){
           if ($res->is_error) { print "Error : ", Dumper($res->error_message); }
           #else { print Dumper($res->result); }
           else { print "bid ".sprintf("%.8f",$base_balance/$bid); }
        } else {
           print $client->status_line;
        }
    }
    print "\n";
}


sub dexp2p_deleteprice {
    my $base = $_[0];
    my $rel = $_[1];

    my $client = new JSON::RPC::Legacy::Client;
    $client->ua->credentials('localhost:10591', 'jsonrpc', 'dexp2p' => 'KeWt2phRPXUPGX');
    my $uri = 'http://localhost:10591/';

    my $obj = { method => 'DEX_cancel', params => ['','',$base,$rel] };
    my $res = $client->call( $uri, $obj );
    if ($res){
       if ($res->is_error) { print "Error : ", Dumper($res->error_message); }
       #else { print Dumper($res->result); }
    } else {
       print $client->status_line;
    }

    $obj = { method => 'DEX_cancel', params => ['','',$rel,$base] };
    $res = $client->call( $uri, $obj );
    if ($res){
       if ($res->is_error) { print "Error : ", Dumper($res->error_message); }
       #else { print Dumper($res->result); }
    } else {
       print $client->status_line;
    }
}


sub dexp2p_getbalance {
    my $rpcport = $_[0];
    my $address = $_[1];

    my $client = new JSON::RPC::Legacy::Client;
    $client->ua->credentials('localhost:'.$rpcport, 'jsonrpc', 'dexp2p' => 'KeWt2phRPXUPGX');
    my $uri = 'http://localhost:'.$rpcport.'/';

    my $obj = { method => 'z_getbalance', params => [$address] };
    my $res = $client->call( $uri, $obj );
    if ($res){
       if ($res->is_error) { print "Error : ", Dumper($res->error_message); }
       else { return $res->result; }
    } else {
       print $client->status_line;
    }
}


sub dex_deleteprice {
    my $ua = LWP::UserAgent->new;
    #$ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    $command = '{"userpass":"'.$userpass.'","method":"cancel_all_orders","cancel_by":{"type":"Pair","data":{"base":"'.$_[1].'","rel":"'.$_[0].'"}}}';
    $req->content($command);
    my $resp = $ua->request($req);
    if ($resp->is_success) {
        print "$_[1]/$_[0] ".$resp->content;
    } else {
        my $biderror1 = eval {from_json($resp->content)->{'error'}};
        if ($@) { print "unknown error $@"; } else { print $biderror1." "; }
    }

    $command = '{"userpass":"'.$userpass.'","method":"cancel_all_orders","cancel_by":{"type":"Pair","data":{"base":"'.$_[0].'","rel":"'.$_[1].'"}}}';
    $req->content($command);
    $resp = $ua->request($req);
    if ($resp->is_success) {
        print " ".$resp->content."\n";
    } else {
        my $askerror1 = eval {from_json($resp->content)->{'error'}};
        if ($@) { print "unknown error $@"; } else { print $askerror1; }
    }
}


sub dex_gettradefee {
    my $coin = $_[0];
    my $ua = LWP::UserAgent->new;
    #$ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    $command = '{"userpass":"'.$userpass.'","method":"get_trade_fee","coin":"'.$coin.'"}';
    $req->content($command);
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return from_json($resp->content)->{'result'}{'amount'};
        } else {
            print "get_trade_fee for $coin error\n";
            print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub dex_getbalance {
    my $coin = $_[0];
    my $ua = LWP::UserAgent->new;
    #$ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    $command = '{"userpass":"'.$userpass.'","method":"my_balance","coin":"'.$coin.'"}';
    $req->content($command);
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            #print Dumper($resp->content);
            return from_json($resp->content)->{'balance'};
        } else {
            print "my_balance for $coin error\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            #print Dumper($resp->content);
            return 0;
        }
}


sub dex_getmintradevol {
    my $coin = $_[0];
    my $ua = LWP::UserAgent->new;
    #$ua->timeout($timeout);
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    $command = '{"userpass":"'.$userpass.'","method":"min_trading_vol","coin":"'.$coin.'"}';
    $req->content($command);
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            #print Dumper($resp->content);
            return from_json($resp->content)->{'result'}{'min_trading_vol'};
        } else {
            print "min_trading_vol for $coin error\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            #print Dumper($resp->content);
            return 0;
        }
}


sub calc_bestprice {
    my $quantity = $_[1];
    my $coin = $_[2];
    foreach (@{$_[0]}) {
        my @array = $_;
        my $price = $array[0][0];
        my $volume = $array[0][1];
        if ( $volume >= $quantity ) {
            return $price;
            last;
        }
    }
}


sub calc_bestprice_sum {
    my $sum = 0;
    my $maxsum = $_[1];
    my $coin = $_[2];
    foreach (@{$_[0]}) {
        my @array = $_;
        my $price = $array[0][0];
        my $volume = $array[0][1];
        $sum += $volume;
        if ( $sum >= $maxsum ) {
            return $price;
            last;
        }
    }
}


sub calc_bestprice_crex24 {
    my $quantity = $_[1];
    my $coin = $_[2];
    foreach (@{$_[0]}) {
        my @array = $_;
        my $price = $array[0]{"price"};
        my $volume = $array[0]{"volume"};
        if ( $volume >= $quantity ) {
            return sprintf("%.7f",$price);
            last;
        }
    }
}


sub calc_bestprice_crex24_sum {
    my $sum = 0;
    my $maxsum = $_[1];
    my $coin = $_[2];
    foreach (@{$_[0]}) {
        my @array = $_;
        my $price = $array[0]{"price"};
        my $volume = $array[0]{"volume"};
        $sum += $volume;
        if ( $sum >= $maxsum ) {
            return sprintf("%.7f",$price);
            last;
        }
    }
}


sub binance_volat {
    my $marginadd = 0.01;
    my $marginadd_1 = 0.01;
    my $marginadd_2 = 0.01;
    my $marginadd_3 = 0.01;

    my $kline_1 = binance_kline("KMD","BTC","15m","3");
    if ( $kline_1 ne "1" ) {
        # marginadd_1 is the oldest
        $marginadd_1 = from_json($kline_1)->[0][2] / from_json($kline_1)->[0][3] - 1;
        $marginadd_2 = from_json($kline_1)->[1][2] / from_json($kline_1)->[1][3] - 1;
        $marginadd_3 = from_json($kline_1)->[2][2] / from_json($kline_1)->[2][3] - 1;
    }
    $marginadd = ($marginadd_1 + $marginadd_2 + $marginadd_3)/3;

    print "volat: ".sprintf("%.3f", $marginadd_1)." ".sprintf("%.3f", $marginadd_2)." ".sprintf("%.3f", $marginadd_3)." / ".sprintf("%.3f", $marginadd)."\n";
    return $marginadd;
}


if ( $api eq "dex_gecko" ) {
    $userpass =  $ENV{'userpass'};
    my $json = read_file("$cwd/mpm.conf.dex");
    $marginsconf = decode_json($json);
    my @stablecoins_usd = ("USDT-BEP20","USDT-PLG20","USDT-AVX20","BUSD-BEP20","BUSD-AVX20","BUSD-PLG20","DAI-BEP20","DAI-AVX20","DAI-PLG20","PAX-BEP20","TUSD-BEP20","USDC-BEP20","USDC-PLG20","USDC-AVX20","SFUSD");
    my @stablecoins_other = ("TRYB-BEP20","TRYB-AVX20","TRYB-PLG20","BIDR-BEP20","JPYC-PLG20","EURS-PLG20","BRZ-BEP20","QC","CADC-PLG20","XSGD-PLG20","JCHF-PLG20","JEUR-PLG20","JGBP-PLG20","NZDS-PLG20");

    my $erc20fee = dex_gettradefee("ETH");
    my $btcfee = dex_gettradefee("BTC");

    my $ids = "ethereum,bitcoin,litecoin,bitcoin-cash,komodo,dogecoin,dash";
    foreach my $coin ( keys %{$marginsconf} ) {
        if ( defined $marginsconf->{$coin}{'geckoid'} ) {
            $ids = $ids.",".$marginsconf->{$coin}{'geckoid'};
        }
    }

    shift @ARGV;
    foreach my $base(@ARGV) {

        my $gecko_price = gecko_latest_price($ids);
        my $freiexchange_price = freiexchange_latest_price();
        my $smartfi_price = smartfi_latest_price();
        my $usdrate_price = komodolive_usdrates();
        #print Dumper($smartfi_price);

        my $base_usd_price = 0;
        my $base_btc_price = 0;
        if ( $base eq "KMD" ) {
            my $binance_price_usd = binance_latest_price("KMDUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"price"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("KMDBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( $base eq "LTC" ) {
            my $binance_price_usd = binance_latest_price("LTCUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"price"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("LTCBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( $base eq "BCH" ) {
            my $binance_price_usd = binance_latest_price("BCHUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"price"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("BCHBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( $base eq "DASH" ) {
            my $binance_price_usd = binance_latest_price("DASHUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"price"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("DASHBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( $base eq "DGB" ) {
            my $binance_price_usd = binance_latest_price("DGBUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"price"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("DGBBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( $base eq "ZEC" ) {
            my $binance_price_usd = binance_latest_price("ZECUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"price"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("ZECBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( $base eq "RVN" ) {
            my $binance_price_usd = binance_latest_price("RVNUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"price"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("RVNBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( $base eq "QTUM" ) {
            my $binance_price_usd = binance_latest_price("QTUMUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"price"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("QTUMBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( ($base eq "DOGE") || ($base eq "DOGE-BEP20") ) {
            my $binance_price_usd = binance_latest_price("DOGEUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"price"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("DOGEBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( ($base eq "FIRO") || ($base eq "FIRO-BEP20") ) {
            my $binance_price_usd = binance_latest_price("FIROUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"price"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("FIROBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( ($base eq "ETH") || ($base eq "ETH-BEP20") || ($base eq "ETH-PLG20") ) {
            my $binance_price_usd = binance_latest_price("ETHUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"price"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("ETHBTC");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( ($base eq "BTC") || ($base eq "BTC-BEP20") ) {
            my $binance_price_usd = binance_latest_price("BTCUSDT");
            if ( $binance_price_usd ne "1" ) { $base_usd_price = from_json($binance_price_usd)->{"price"}; } else { $base_usd_price = 0; }
            $base_btc_price = 1;
        } elsif ( ($base eq "EURS-PLG20") || ($base eq "JEUR-PLG20") ) {
            if ( $usdrate_price ne "1" ) { $base_usd_price = 1 / from_json($usdrate_price)->{"rates"}{"EUR"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("BTCEUR");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = 1 / from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( ($base eq "TRYB-BEP20") || ($base eq "TRYB-AVX20") || ($base eq "TRYB-PLG20") ) {
            if ( $usdrate_price ne "1" ) { $base_usd_price = 1 / from_json($usdrate_price)->{"rates"}{"TRY"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("BTCTRY");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = 1 / from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( $base eq "QC" ) {
            if ( $usdrate_price ne "1" ) { $base_usd_price = 1 / from_json($usdrate_price)->{"rates"}{"CNY"}; } else { $base_usd_price = 0; }
            if ( $gecko_price ne "1" ) { $base_btc_price = 1 / from_json($gecko_price)->{"bitcoin"}{"cny"}; } else { $base_btc_price = 0; }
        } elsif ( $base eq "CADC-PLG20" ) {
            if ( $usdrate_price ne "1" ) { $base_usd_price = 1 / from_json($usdrate_price)->{"rates"}{"CAD"}; } else { $base_usd_price = 0; }
            if ( $gecko_price ne "1" ) { $base_btc_price = 1 / from_json($gecko_price)->{"bitcoin"}{"cad"}; } else { $base_btc_price = 0; }
        } elsif ( $base eq "XSGD-PLG20" ) {
            if ( $usdrate_price ne "1" ) { $base_usd_price = 1 / from_json($usdrate_price)->{"rates"}{"SGD"}; } else { $base_usd_price = 0; }
            if ( $gecko_price ne "1" ) { $base_btc_price = 1 / from_json($gecko_price)->{"bitcoin"}{"sgd"}; } else { $base_btc_price = 0; }
        } elsif ( $base eq "NZDS-PLG20" ) {
            if ( $usdrate_price ne "1" ) { $base_usd_price = 1 / from_json($usdrate_price)->{"rates"}{"NZD"}; } else { $base_usd_price = 0; }
            if ( $gecko_price ne "1" ) { $base_btc_price = 1 / from_json($gecko_price)->{"bitcoin"}{"nzd"}; } else { $base_btc_price = 0; }
        } elsif ( $base eq "JCHF-PLG20" ) {
            if ( $usdrate_price ne "1" ) { $base_usd_price = 1 / from_json($usdrate_price)->{"rates"}{"CHF"}; } else { $base_usd_price = 0; }
            if ( $gecko_price ne "1" ) { $base_btc_price = 1 / from_json($gecko_price)->{"bitcoin"}{"chf"}; } else { $base_btc_price = 0; }
        } elsif ( $base eq "JGBP-PLG20" ) {
            if ( $usdrate_price ne "1" ) { $base_usd_price = 1 / from_json($usdrate_price)->{"rates"}{"GBP"}; } else { $base_usd_price = 0; }
            my $binance_price_btc = binance_latest_price("BTCGBP");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = 1 / from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        } elsif ( $base ~~ @stablecoins_usd ) {
            $base_usd_price = 1;
            my $binance_price_btc = binance_latest_price("BTCUSDT");
            if ( $binance_price_btc ne "1" ) { $base_btc_price = 1 / from_json($binance_price_btc)->{"price"}; } else { $base_btc_price = 0; }
        }

        if ( ($base_usd_price ne "0") && ($base_btc_price ne "0") ) {

             my $base_mintradevol = dex_getmintradevol($base);
             my $base_balance = dex_getbalance($base);

            foreach my $coin ( keys %{$marginsconf} ) {
                if ( ($base eq $coin) || ( (($base eq "ETH-BEP20") || ($base eq "ETH-PLG20")) && ($coin eq "ETH")) ) { next; }
                my $geckoid = $marginsconf->{$coin}{'geckoid'};
                my $type = $marginsconf->{$coin}{'type'};
                if ( !defined $type ) { $type = "utxo"; }

                my $binance_usd_symbol = $marginsconf->{$coin}{'binance_usd_symbol'};
                my $binance_btc_symbol = $marginsconf->{$coin}{'binance_btc_symbol'};
                my $safetrade_btc_symbol = $marginsconf->{$coin}{'safetrade_btc_symbol'};
                my $freiexchange_btc_symbol = $marginsconf->{$coin}{'freiexchange_btc_symbol'};
                my $crex24_btc_symbol = $marginsconf->{$coin}{'crex24_btc_symbol'};
                my $bittrex_btc_symbol = $marginsconf->{$coin}{'bittrex_btc_symbol'};
                my $bittrex_usd_symbol = $marginsconf->{$coin}{'bittrex_usd_symbol'};
                my $coinex_usd_symbol = $marginsconf->{$coin}{'coinex_usd_symbol'};
                my $kucoin_usd_symbol = $marginsconf->{$coin}{'kucoin_usd_symbol'};
                my $hitbtc_btc_symbol = $marginsconf->{$coin}{'hitbtc_btc_symbol'};
                my $bithumb_usd_symbol = $marginsconf->{$coin}{'bithumb_usd_symbol'};
                my $southxchange_btc_symbol = $marginsconf->{$coin}{'southxchange_btc_symbol'};
                my $komodolive_usd_symbol = $marginsconf->{$coin}{'komodolive_usd_symbol'};
                my $smartfi_usd_symbol = $marginsconf->{$coin}{'smartfi_usd_symbol'};
                my $usdrate_symbol = $marginsconf->{$coin}{'usdrate_symbol'};
                my $price = 0;
                my $change = 0;
                my $coinusdprice = 0;
                my $btcusdprice = 0;
                my $ethusdprice = 0;
                if ( $gecko_price ne "1" ) {
                    $btcusdprice = from_json($gecko_price)->{"bitcoin"}{"usd"};
                    $ethusdprice = from_json($gecko_price)->{"ethereum"}{"usd"};
                } else {
                    my $binance_btcusdprice = binance_latest_price("BTCUSDT");
                    if ( $binance_btcusdprice ne "1" ) { $btcusdprice = from_json($binance_btcusdprice)->{"price"}; }
                    my $binance_ethusdprice = binance_latest_price("ETHUSDT");
                    if ( $binance_ethusdprice ne "1" ) { $ethusdprice = from_json($binance_ethusdprice)->{"price"}; }
                }

                if ( (defined $geckoid) && ($gecko_price ne "1") ) {
                    $price = from_json($gecko_price)->{$geckoid}{"usd"} / $base_usd_price;
                    $coinusdprice = from_json($gecko_price)->{$geckoid}{"usd"};
                    if ( defined from_json($gecko_price)->{$geckoid}{"usd_24h_change"} ) { $change = abs(from_json($gecko_price)->{$geckoid}{"usd_24h_change"}); }
                    if ( (($coin ~~ @stablecoins_usd) || ($coin ~~ @stablecoins_other)) && (defined from_json($gecko_price)->{$geckoid}{"btc_24h_change"}) ) { $change = abs(from_json($gecko_price)->{$geckoid}{"btc_24h_change"}); }
                }

                if ( defined $binance_usd_symbol ) {
                    my $binance_price = binance_latest_price($binance_usd_symbol);
                    if ( $binance_price ne "1" ) {
                        $price = from_json($binance_price)->{"price"} / $base_usd_price;
                        $coinusdprice = from_json($binance_price)->{"price"};
                    }
                } elsif ( defined $binance_btc_symbol ) {
                    my $binance_price = binance_latest_price($binance_btc_symbol);
                    if ( $binance_price ne "1" ) {
                        $price = from_json($binance_price)->{"price"} / $base_btc_price;
                        $coinusdprice = from_json($binance_price)->{"price"} * $btcusdprice;
                    }
                } elsif ( defined $safetrade_btc_symbol ) {
                    my $safetrade_price = safetrade_latest_price($safetrade_btc_symbol);
                    if ( $safetrade_price ne "1" ) {
                        $price = ( from_json($safetrade_price)->{"ticker"}{"sell"} + from_json($safetrade_price)->{"ticker"}{"buy"} + from_json($safetrade_price)->{"ticker"}{"last"} ) / 3 / $base_btc_price;
                        $coinusdprice = ( from_json($safetrade_price)->{"ticker"}{"sell"} + from_json($safetrade_price)->{"ticker"}{"buy"} + from_json($safetrade_price)->{"ticker"}{"last"} ) / 3 * $btcusdprice;
                        $change = (1 - from_json($safetrade_price)->{"ticker"}{"low"} / from_json($safetrade_price)->{"ticker"}{"high"}) * 100;
                    }
                } elsif ( defined $southxchange_btc_symbol ) {
                    my $southxchange_price = southxchange_latest_price($southxchange_btc_symbol);
                    if ( $southxchange_price ne "1" ) {
                        $price = ( from_json($southxchange_price)->{"Bid"} + from_json($southxchange_price)->{"Ask"} + from_json($southxchange_price)->{"Last"} ) / 3 / $base_btc_price;
                        $coinusdprice = ( from_json($southxchange_price)->{"Bid"} + from_json($southxchange_price)->{"Ask"} + from_json($southxchange_price)->{"Last"} ) / 3 * $btcusdprice;
                        $change = abs(from_json($southxchange_price)->{"Variation24Hr"});
                    }
                } elsif ( defined $komodolive_usd_symbol ) {
                    my $komodolive_price = komodolive_latest_price($komodolive_usd_symbol);
                    if ( $komodolive_price ne "1" ) {
                        $coinusdprice = from_json($komodolive_price)->{"last_price"};
                        $price = $coinusdprice / $base_usd_price;
                        $change = abs(from_json($komodolive_price)->{"change_24h"});
                    }
                } elsif ( (defined $freiexchange_btc_symbol) && ($freiexchange_price ne "1") ) {
                    $price = ( from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"highestBuy"} + from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"lowestSell"} + from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"last"} ) / 3 / $base_btc_price;
                    $coinusdprice = ( from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"highestBuy"} + from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"lowestSell"} + from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"last"} ) / 3 * $btcusdprice;
                    $change = abs(from_json($freiexchange_price)->{$freiexchange_btc_symbol}->[0]{"percent_change_24h"});
                } elsif ( (defined $smartfi_usd_symbol) && ($smartfi_price ne "1") ) {
                    $price = ( from_json($smartfi_price)->{"data"}{$smartfi_usd_symbol}{"HeighestBid"} + from_json($smartfi_price)->{"data"}{$smartfi_usd_symbol}{"LowestAsk"} + from_json($smartfi_price)->{"data"}{$smartfi_usd_symbol}{"Last"} ) / 3 / $base_usd_price;
                    $coinusdprice = ( from_json($smartfi_price)->{"data"}{$smartfi_usd_symbol}{"HeighestBid"} + from_json($smartfi_price)->{"data"}{$smartfi_usd_symbol}{"LowestAsk"} + from_json($smartfi_price)->{"data"}{$smartfi_usd_symbol}{"Last"} ) / 3;
                    $change = abs(from_json($smartfi_price)->{"data"}{$smartfi_usd_symbol}{"PercentChange"});
                } elsif ( (defined $usdrate_symbol) && ($usdrate_price ne "1") ) {
                    $coinusdprice = 1 / from_json($usdrate_price)->{"rates"}{"$usdrate_symbol"};
                    $price = $coinusdprice / $base_usd_price;
                } elsif ( defined $crex24_btc_symbol ) {
                    my $crex24_price = crex24_latest_price($crex24_btc_symbol);
                    if ( $crex24_price ne "1" ) {
                        my $crex24_bid = from_json($crex24_price)->[0]{"bid"};
                        if ( !defined $crex24_bid ) { $crex24_bid = 0; }
                        $price = ( from_json($crex24_price)->[0]{"ask"} + $crex24_bid + from_json($crex24_price)->[0]{"last"} ) / 3 / $base_btc_price;
                        $coinusdprice = ( from_json($crex24_price)->[0]{"ask"} + $crex24_bid + from_json($crex24_price)->[0]{"last"} ) / 3 * $btcusdprice;
                        $change = abs(from_json($crex24_price)->[0]{"percentChange"});
                    }
                } elsif ( defined $bittrex_btc_symbol ) {
                    my $bittrex_price = bittrex_latest_price($bittrex_btc_symbol);
                    if ( $bittrex_price ne "1" ) {
                        $price = ( from_json($bittrex_price)->{"askRate"} + from_json($bittrex_price)->{"bidRate"} + from_json($bittrex_price)->{"lastTradeRate"} ) / 3 / $base_btc_price;
                        $coinusdprice = ( from_json($bittrex_price)->{"askRate"} + from_json($bittrex_price)->{"bidRate"} + from_json($bittrex_price)->{"lastTradeRate"} ) / 3 * $btcusdprice;
                    }
                    my $bittrex_sum = bittrex_summary($bittrex_btc_symbol);
                    if ( $bittrex_sum ne "1" ) {
                        $change = (1 - from_json($bittrex_sum)->{"low"} / from_json($bittrex_sum)->{"high"}) * 100;
                    }
                } elsif ( defined $bittrex_usd_symbol ) {
                    my $bittrex_price = bittrex_latest_price($bittrex_usd_symbol);
                    if ( $bittrex_price ne "1" ) {
                        $price = ( from_json($bittrex_price)->{"askRate"} + from_json($bittrex_price)->{"bidRate"} + from_json($bittrex_price)->{"lastTradeRate"} ) / 3 / $base_usd_price;
                        $coinusdprice = ( from_json($bittrex_price)->{"askRate"} + from_json($bittrex_price)->{"bidRate"} + from_json($bittrex_price)->{"lastTradeRate"} ) / 3;
                    }
                    my $bittrex_sum = bittrex_summary($bittrex_usd_symbol);
                    if ( $bittrex_sum ne "1" ) {
                        $change = (1 - from_json($bittrex_sum)->{"low"} / from_json($bittrex_sum)->{"high"}) * 100;
                    }
                } elsif ( defined $coinex_usd_symbol ) {
                    my $coinex_price = coinex_latest_price($coinex_usd_symbol);
                    if ( $coinex_price ne "1" ) {
                        $price = ( from_json($coinex_price)->{"data"}{"ticker"}{"sell"} + from_json($coinex_price)->{"data"}{"ticker"}{"buy"} + from_json($coinex_price)->{"data"}{"ticker"}{"last"} ) / 3 / $base_usd_price;
                        $coinusdprice = ( from_json($coinex_price)->{"data"}{"ticker"}{"sell"} + from_json($coinex_price)->{"data"}{"ticker"}{"buy"} + from_json($coinex_price)->{"data"}{"ticker"}{"last"} ) / 3;
                        $change = (1 - from_json($coinex_price)->{"data"}{"ticker"}{"low"} / from_json($coinex_price)->{"data"}{"ticker"}{"high"}) * 100;
                    }
                } elsif ( defined $kucoin_usd_symbol ) {
                    my $kucoin_price = kucoin_latest_price($kucoin_usd_symbol);
                    if ( $kucoin_price ne "1" ) {
                        $price = ( $kucoin_price->{"bestBid"} + $kucoin_price->{"bestAsk"} + $kucoin_price->{"price"} ) / 3 / $base_usd_price;
                        $coinusdprice = ( $kucoin_price->{"bestBid"} + $kucoin_price->{"bestAsk"} + $kucoin_price->{"price"} ) / 3;
                    }
                } elsif ( defined $hitbtc_btc_symbol ) {
                    my $hitbtc_price = hitbtc_latest_price($hitbtc_btc_symbol);
                    if ( $hitbtc_price ne "1" ) {
                        $price = ( from_json($hitbtc_price)->{"ask"} + from_json($hitbtc_price)->{"bid"} + from_json($hitbtc_price)->{"last"} ) / 3 / $base_btc_price;
                        $coinusdprice = ( from_json($hitbtc_price)->{"ask"} + from_json($hitbtc_price)->{"bid"} + from_json($hitbtc_price)->{"last"} ) / 3 * $btcusdprice;
                        $change = (1 - from_json($hitbtc_price)->{"low"} / from_json($hitbtc_price)->{"high"}) * 100;
                    }
                } elsif ( defined $bithumb_usd_symbol ) {
                    my $bithumb_price = bithumb_latest_price($bithumb_usd_symbol);
                    if ( $bithumb_price ne "1" ) {
                        $price = from_json($bithumb_price)->{"data"}[0]{"c"} / $base_usd_price;
                        $coinusdprice = from_json($bithumb_price)->{"data"}[0]{"c"};
                        $change = (1 - from_json($bithumb_price)->{"data"}[0]{"l"} / from_json($bithumb_price)->{"data"}[0]{"h"}) * 100;
                    }
                }

                my $marginadd = 0;
                if ( (($base eq "KMD") && ($coin eq "KMD-BEP20")) || (($base eq "DOGE-BEP20") && ($coin eq "DOGE")) || (($base eq "DOGE") && ($coin eq "DOGE-BEP20")) || (($coin ~~ @stablecoins_usd) && ($base ~~ @stablecoins_usd)) ) {
                    $price = 1;
                } elsif ( (defined $binance_usd_symbol) || (defined $binance_btc_symbol) || (defined $usdrate_symbol) ) {
                    $marginadd = $change/100/4.5;
                } elsif ( defined $komodolive_usd_symbol ) {
                    $marginadd = $change/100/1.5;
                } else {
                    $marginadd = $change/100/2.5;
                }
                #print "change: $change, marginadd: $marginadd\n";

                my $bid1 = undef;
                my $bid2 = undef;
                my $ask1 = undef;
                my $ask2 = undef;
                my $askmargin1 = undef;
                my $askmargin2 = undef;
                my $bidmargin1 = undef;
                my $bidmargin2 = undef;
                if ( defined $marginsconf->{$coin}{'askmargin'} ) {
                    $askmargin1 = $marginsconf->{$coin}{'askmargin'} + $marginadd;
                    if ( ($base eq "KMD") || ($coin eq "KMD") || ($coin eq "KMD-BEP20") ) { $askmargin1 = $askmargin1 * 0.85; }
                    $askmargin2 = $askmargin1 * 1.5;
                    if ( (($base eq "KMD") && ($coin eq "KMD-BEP20")) || (($base eq "DOGE-BEP20") && ($coin eq "DOGE")) || (($base eq "DOGE") && ($coin eq "DOGE-BEP20")) || (($coin ~~ @stablecoins_usd) && ($base ~~ @stablecoins_usd)) ) {
                        $askmargin1 = $askmargin1/2;
                        $askmargin2 = $askmargin2/2;
                    }
                    if ($price ne "0") {
                        $ask1 = sprintf("%.10f", $price + $price * $askmargin1);
                        $ask2 = sprintf("%.10f", $price + $price * $askmargin2);
                    }
                }
                if ( defined $marginsconf->{$coin}{'bidmargin'} ) {
                    $bidmargin1 = $marginsconf->{$coin}{'bidmargin'} + $marginadd;
                    if ( ($base eq "KMD") || ($coin eq "KMD") || ($coin eq "KMD-BEP20") ) { $bidmargin1 = $bidmargin1 * 0.85; }
                    $bidmargin2 = $bidmargin1 * 1.5;
                    if ( (($base eq "KMD") && ($coin eq "KMD-BEP20")) || (($base eq "DOGE-BEP20") && ($coin eq "DOGE")) || (($base eq "DOGE") && ($coin eq "DOGE-BEP20")) || (($coin ~~ @stablecoins_usd) && ($base ~~ @stablecoins_usd)) ) {
                        $bidmargin1 = $bidmargin1/2;
                        $bidmargin2 = $bidmargin2/2;
                    }
                    if ( $bidmargin1 > 0.96 ) { $bidmargin1 = 0.96; }
                    if ( $bidmargin2 > 0.98 ) { $bidmargin2 = 0.98; }
                    my $low = $price - $price * $bidmargin2;
                    if ( $low < 0.00000001 ) { print "kaputt: $coin, price: $low\n"; }
                    if ($price ne "0") {
                        $bid1 = sprintf("%.10f", 1 / ($price - $price * $bidmargin1));
                        $bid2 = sprintf("%.10f", 1 / ($price - $price * $bidmargin2));
                    }
                }

                my $minaskvolume_btc = undef;
                my $minbidvolume_btc = undef;
                my $minaskvolume_eth = undef;
                my $minbidvolume_eth = undef;
                my $maxbidvolume = undef;
                my $minbidvolume = undef;
                my $maxaskvolume = undef;
                my $minaskvolume = undef;
                my $maxbidvolume_usd = $marginsconf->{$coin}{'maxbidvolume'};
                if ( defined $maxbidvolume_usd ) { $maxbidvolume = $maxbidvolume_usd / $base_usd_price; }
                my $minbidvolume_usd = $marginsconf->{$coin}{'minbidvolume'};
                if ( defined $minbidvolume_usd ) { $minbidvolume = $minbidvolume_usd / $base_usd_price; }
                my $maxaskvolume_usd = $marginsconf->{$coin}{'maxaskvolume'};
                if ( defined $maxaskvolume_usd && $coinusdprice ne "0" ) { $maxaskvolume = $maxaskvolume_usd / $coinusdprice; }
                my $minaskvolume_usd = $marginsconf->{$coin}{'minaskvolume'};
                if ( defined $minaskvolume_usd && $coinusdprice ne "0" ) { $minaskvolume = $minaskvolume_usd / $coinusdprice; }
                if ( ($base eq "BTC") && ($type eq "erc20") ) {
                    if ( ($erc20fee eq "1") || ($btcfee eq "1") || ($coinusdprice eq "0") ) {
                        $price = 0;
                    } else {
                        $minaskvolume_btc = $btcfee * $btcusdprice / $coinusdprice * 15;
                        $minbidvolume_btc = $btcfee * 15;
                        $minaskvolume_eth = $erc20fee * $ethusdprice / $coinusdprice * 30;
                        $minbidvolume_eth = $erc20fee * $ethusdprice / $base_usd_price * 30;
                        $minaskvolume = max($minaskvolume_btc,$minaskvolume_eth);
                        $minbidvolume = max($minbidvolume_btc,$minbidvolume_eth);
                    }
                } elsif ( ($base eq "BTC") || ($coin eq "BTC") ) {
                    if ( ($btcfee eq "1") || ($coinusdprice eq "0") ) {
                        $price = 0;
                    } else {
                        $minaskvolume_btc = $btcfee * $btcusdprice / $coinusdprice * 15;
                        $minbidvolume_btc = $btcfee * 15;
                        $minaskvolume = $minaskvolume_btc;
                        $minbidvolume = $minbidvolume_btc;
                    }
                } elsif ($type eq "erc20") {
                    if ( ($erc20fee eq "1") || ($coinusdprice eq "0") ) {
                        $price = 0;
                    } else {
                        $minaskvolume_eth = $erc20fee * $ethusdprice / $coinusdprice * 30;
                        $minbidvolume_eth = $erc20fee * $ethusdprice / $base_usd_price * 30;
                        $minaskvolume = $minaskvolume_eth;
                        $minbidvolume = $minbidvolume_eth;
                    }
                } elsif ( (($base eq "KMD") && ($coin eq "KMD-BEP20")) || (($base eq "DOGE") && ($coin eq "DOGE-BEP20")) || (($coin ~~ @stablecoins_usd) && ($base ~~ @stablecoins_usd)) ) {
                    if ($coinusdprice eq "0") {
                        $price = 0;
                    } else {
                        $minaskvolume = 9 / $coinusdprice;
                        $minbidvolume = 9 / $base_usd_price;
                    }
                } elsif ( ($type eq "bep20") || (index($base, "BEP20") != -1) ) {
                    if ($coinusdprice eq "0") {
                        $price = 0;
                    } else {
                        $minaskvolume = 3.5 / $coinusdprice;
                        $minbidvolume = 3.5 / $base_usd_price;
                    }
                } elsif ( ($type eq "plg20") || (index($base, "PLG20") != -1) ) {
                    if ($coinusdprice eq "0") {
                        $price = 0;
                    } else {
                        $minaskvolume = 3.5 / $coinusdprice;
                        $minbidvolume = 3.5 / $base_usd_price;
                    }
                }

                if ($price eq "0") {
                    dex_deleteprice($base,$coin);
                } else {
                    my $rel_mintradevol = dex_getmintradevol($coin);
                    my $rel_balance = dex_getbalance($coin);
                    dex_setprice($base,$coin,$bid1,$ask1,$bid2,$ask2,$maxbidvolume,$minbidvolume,$maxaskvolume,$minaskvolume,$bidmargin1,$askmargin1,$bidmargin2,$askmargin2,$coinusdprice,$rel_mintradevol,$base_mintradevol,$rel_balance,$base_balance);
                }

                Time::HiRes::sleep(0.4);
            }
        }
    }

} elsif ( $api eq "dex_paprika" ) {
    $userpass =  $ENV{'userpass'};
    my $json = read_file("$cwd/mpm.conf.dex.$base");
    $marginsconf = decode_json($json);
#    my $marginadd = binance_volat();
    my $marginadd = 0;
    foreach my $coin ( keys %{$marginsconf} ) {
        my $price = undef;
        my $diff_1 = 0;
        my $diff_2 = 0;
        my $papid = $marginsconf->{$coin}{'papid'};
        my $tradefee = dex_gettradefee($coin);
        my $maxfee = $marginsconf->{$coin}{'maxfee'};
        if ( !defined $maxfee ) { $maxfee = "100"; }

        my $paprika_price = paprika_latest_price($basepapid,$papid);
#        my $weightedprice = from_json(dex_ticker_24h($coin,$base))->[0]{'weightedAvgPrice'};
        if ( $paprika_price ne "1" ) {
            $price = from_json($paprika_price)->{'price'};
            my $format = DateTime::Format::Strptime->new( pattern => '%FT%T%z');
            my $base_updated = from_json($paprika_price)->{'base_price_last_updated'};
            my $basetime = $format->parse_datetime($base_updated);
            my $quote_updated = from_json($paprika_price)->{'quote_price_last_updated'};
            my $quotetime = $format->parse_datetime($quote_updated);
            my $now = DateTime->now;
            $diff_1 = $now->epoch - $basetime->epoch;
            $diff_2 = $now->epoch - $quotetime->epoch;
            print "$diff_1 $diff_2 ";
        }

        if ( (!defined $price) || ($tradefee > $maxfee) ) {
            dex_deleteprice($base,$coin);
        } elsif ( ($diff_1 < 180) || ($diff_2 < 180) ) {
            dex_setprice($base,$coin,$price,$marginadd);
        }
    }

} elsif ( $api eq "dexp2p" ) {
    my $json = read_file("$cwd/mpm.conf.dexp2p");
    $marginsconf = decode_json($json);
#    my $baseamount = dexp2p_getbalance(7771,$recvaddr);
    my $baseamount = 10;
    foreach my $coin ( keys %{$marginsconf} ) {
        my $rpcport = $marginsconf->{$coin}{'rpcport'};
#        my $relamount = dexp2p_getbalance($rpcport,$recvaddr);
        my $relamount = $marginsconf->{$coin}{'amount'};
        my $papid = $marginsconf->{$coin}{'papid'};
        my $baseprice = from_json(paprika_price($papid,$basepapid,$relamount))->{'price'};
        my $relprice = from_json(paprika_price($basepapid,$papid,$baseamount))->{'price'};
        dexp2p_deleteprice($base,$coin);
        dexp2p_setprice($base,$coin,$baseprice,$relprice,$baseamount,$relamount);
    }

} elsif ( $api eq "binance" ) {
    my $json = read_file("$cwd/mpm.conf.binance");
    my $marginsconf = decode_json($json);
    #my $marginadd = binance_volat();
    my $marginadd = 0;

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_1'} + $marginadd/50);
        my $bidmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_2'} + $marginadd/25);
        my $bidmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_3'} + $marginadd/10);
        my $askmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_1'} + $marginadd/50);
        my $askmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_2'} + $marginadd/25);
        my $askmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_3'} + $marginadd/10);
        my $quantity_1 = $marginsconf->{$coin}{'quantity_1'};
        my $quantity_2 = $marginsconf->{$coin}{'quantity_2'};
        my $quantity_3 = $marginsconf->{$coin}{'quantity_3'};
        my $maxsum_1 = $marginsconf->{$coin}{'maxsum_1'};
        my $maxsum_2 = $marginsconf->{$coin}{'maxsum_2'};
        my $maxsum_3 = $marginsconf->{$coin}{'maxsum_3'};

        binance_cancelorders($base,$coin);

        my $binance_book_price = decode_json(binance_book_price($base,$coin));
        my $cex_price = sprintf("%.8f", ($binance_book_price->{'bidPrice'} + $binance_book_price->{'askPrice'})/2);
        my $binance_depth = decode_json(binance_depth($base,$coin));

        if ( ($binance_depth ne "1") && ($binance_book_price ne "1") ) {
            my $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_1));
            my $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_1));
            if (( $coin eq "BUSD" ) || ( $coin eq "USDT" )) {
                $cex_bid_price_1 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_1,$coin) + 0.00010000;
                $cex_ask_price_1 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_1,$coin) - 0.00010000;
            } elsif ( $coin eq "ETH" ) {
                $cex_bid_price_1 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_1,$coin) + 0.00000010;
                $cex_ask_price_1 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_1,$coin) - 0.00000010;
            } else {
                $cex_bid_price_1 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_1,$coin) + 0.00000001;
                $cex_ask_price_1 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_1,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_1 eq "0.00000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = $maxbidprice; }
            if ( ( $cex_ask_price_1 eq "0.00000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = $minaskprice; }

            $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_2));
            $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_2));
            if (( $coin eq "BUSD" ) || ( $coin eq "USDT" )) {
                $cex_bid_price_2 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_2,$coin) + 0.00010000;
                $cex_ask_price_2 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_2,$coin) - 0.00010000;
            } elsif ( $coin eq "ETH" ) {
                $cex_bid_price_2 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_2,$coin) + 0.00000010;
                $cex_ask_price_2 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_2,$coin) - 0.00000010;
            } else {
                $cex_bid_price_2 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_2,$coin) + 0.00000001;
                $cex_ask_price_2 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_2,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_2 eq "0.00000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
            if ( ( $cex_ask_price_2 eq "0.00000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }

            $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_3));
            $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_3));
            if (( $coin eq "BUSD" ) || ( $coin eq "USDT" )) {
                $cex_bid_price_3 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_3,$coin) + 0.00010000;
                $cex_ask_price_3 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_3,$coin) - 0.00010000;
            } elsif ( $coin eq "ETH" ) {
                $cex_bid_price_3 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_3,$coin) + 0.00000010;
                $cex_ask_price_3 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_3,$coin) - 0.00000010;
            } else {
                $cex_bid_price_3 = calc_bestprice_sum($binance_depth->{'bids'},$maxsum_3,$coin) + 0.00000001;
                $cex_ask_price_3 = calc_bestprice_sum($binance_depth->{'asks'},$maxsum_3,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_3 eq "0.00000001" ) || ( $cex_bid_price_3 > $maxbidprice ) ) { $cex_bid_price_3 = $maxbidprice; }
            if ( ( $cex_ask_price_3 eq "0.00000001" ) || ( $cex_ask_price_3 < $minaskprice ) ) { $cex_ask_price_3 = $minaskprice; }

            #print "$cex_ask_price_1 $cex_ask_price_2 $cex_ask_price_3\n";
            binance_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
            binance_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
            binance_setprice($base,$coin,$cex_bid_price_3,$cex_ask_price_3,$quantity_3);
        }
    }


} elsif ( $api eq "kucoin" ) {
    my $json = read_file("$cwd/mpm.conf.kucoin");
    my $marginsconf = decode_json($json);
    #my $marginadd = binance_volat();
    my $marginadd = 0;

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_1'} + $marginadd/50);
        my $bidmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_2'} + $marginadd/25);
        my $bidmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_3'} + $marginadd/10);
        my $askmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_1'} + $marginadd/50);
        my $askmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_2'} + $marginadd/25);
        my $askmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_3'} + $marginadd/10);
        my $quantity_1 = $marginsconf->{$coin}{'quantity_1'};
        my $quantity_2 = $marginsconf->{$coin}{'quantity_2'};
        my $quantity_3 = $marginsconf->{$coin}{'quantity_3'};
        my $maxsum_1 = $marginsconf->{$coin}{'maxsum_1'};
        my $maxsum_2 = $marginsconf->{$coin}{'maxsum_2'};
        my $maxsum_3 = $marginsconf->{$coin}{'maxsum_3'};

        kucoin_cancelorders($base,$coin);
        Time::HiRes::sleep(1);

        my $kucoin_book_price = kucoin_book_price($base,$coin);
        my $cex_price = sprintf("%.8f", ($kucoin_book_price->{'bestBid'} + $kucoin_book_price->{'bestAsk'})/2);
#        my $binance_book_price = decode_json(binance_book_price($base,$coin));
#        my $cex_price = sprintf("%.8f", ($binance_book_price->{'bidPrice'} + $binance_book_price->{'askPrice'})/2);

        my $kucoin_depth = kucoin_depth($base,$coin);

        if ( ($kucoin_depth ne "1") && ($kucoin_book_price ne "1") ) {
#        if ( ($kucoin_depth ne "1") && ($binance_book_price ne "1") ) {
            my $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_1));
            my $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_1));
            if (( $coin eq "BUSD" ) || ( $coin eq "USDT" )) {
                $cex_bid_price_1 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_1,$coin) + 0.00010000;
                $cex_ask_price_1 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_1,$coin) - 0.00010000;
            } else {
                $cex_bid_price_1 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_1,$coin) + 0.00000001;
                $cex_ask_price_1 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_1,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_1 eq "0.00000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = $maxbidprice; }
            if ( ( $cex_ask_price_1 eq "0.00000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = $minaskprice; }

            $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_2));
            $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_2));
            if (( $coin eq "BUSD" ) || ( $coin eq "USDT" )) {
                $cex_bid_price_2 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_2,$coin) + 0.00010000;
                $cex_ask_price_2 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_2,$coin) - 0.00010000;
            } else {
                $cex_bid_price_2 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_2,$coin) + 0.00000001;
                $cex_ask_price_2 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_2,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_2 eq "0.00000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
            if ( ( $cex_ask_price_2 eq "0.00000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }

            $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_3));
            $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_3));
            if (( $coin eq "BUSD" ) || ( $coin eq "USDT" )) {
                $cex_bid_price_3 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_3,$coin) + 0.00010000;
                $cex_ask_price_3 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_3,$coin) - 0.00010000;
            } else {
                $cex_bid_price_3 = calc_bestprice_sum($kucoin_depth->{'bids'},$maxsum_3,$coin) + 0.00000001;
                $cex_ask_price_3 = calc_bestprice_sum($kucoin_depth->{'asks'},$maxsum_3,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_3 eq "0.00000001" ) || ( $cex_bid_price_3 > $maxbidprice ) ) { $cex_bid_price_3 = $maxbidprice; }
            if ( ( $cex_ask_price_3 eq "0.00000001" ) || ( $cex_ask_price_3 < $minaskprice ) ) { $cex_ask_price_3 = $minaskprice; }

            kucoin_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
            kucoin_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
            kucoin_setprice($base,$coin,$cex_bid_price_3,$cex_ask_price_3,$quantity_3);
        }
    }


} elsif ( $api eq "mandala" ) {
    my $json = read_file("$cwd/mpm.conf.mandala");
    my $marginsconf = decode_json($json);
    #my $marginadd = mandala_volat();
    my $marginadd = 0;

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_1'} + $marginadd/50);
        my $bidmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_2'} + $marginadd/25);
        my $bidmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_3'} + $marginadd/10);
        my $askmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_1'} + $marginadd/50);
        my $askmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_2'} + $marginadd/25);
        my $askmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_3'} + $marginadd/10);
        my $quantity_1 = $marginsconf->{$coin}{'quantity_1'};
        my $quantity_2 = $marginsconf->{$coin}{'quantity_2'};
        my $quantity_3 = $marginsconf->{$coin}{'quantity_3'};
        my $maxsum_1 = $marginsconf->{$coin}{'maxsum_1'};
        my $maxsum_2 = $marginsconf->{$coin}{'maxsum_2'};
        my $maxsum_3 = $marginsconf->{$coin}{'maxsum_3'};

        mandala_cancelorders($base,$coin);

        my $mandala_book_price = decode_json(binance_book_price($base,$coin));
        my $cex_price = sprintf("%.8f", ($mandala_book_price->{'bidPrice'} + $mandala_book_price->{'askPrice'})/2);
        my $mandala_depth = decode_json(binance_depth($base,$coin));

        if ( ($mandala_depth ne "1") && ($mandala_book_price ne "1") ) {
            my $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_1));
            my $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_1));
            if (( $coin eq "BUSD" ) || ( $coin eq "USDT" )) {
                $cex_bid_price_1 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_1,$coin) + 0.00010000;
                $cex_ask_price_1 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_1,$coin) - 0.00010000;
            } elsif ( $coin eq "ETH" ) {
                $cex_bid_price_1 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_1,$coin) + 0.00000010;
                $cex_ask_price_1 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_1,$coin) - 0.00000010;
            } else {
                $cex_bid_price_1 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_1,$coin) + 0.00000001;
                $cex_ask_price_1 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_1,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_1 eq "0.00000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = $maxbidprice; }
            if ( ( $cex_ask_price_1 eq "0.00000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = $minaskprice; }

            $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_2));
            $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_2));
            if (( $coin eq "BUSD" ) || ( $coin eq "USDT" )) {
                $cex_bid_price_2 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_2,$coin) + 0.00010000;
                $cex_ask_price_2 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_2,$coin) - 0.00010000;
            } elsif ( $coin eq "ETH" ) {
                $cex_bid_price_2 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_2,$coin) + 0.00000010;
                $cex_ask_price_2 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_2,$coin) - 0.00000010;
            } else {
                $cex_bid_price_2 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_2,$coin) + 0.00000001;
                $cex_ask_price_2 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_2,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_2 eq "0.00000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
            if ( ( $cex_ask_price_2 eq "0.00000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }

            $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_3));
            $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_3));
            if (( $coin eq "BUSD" ) || ( $coin eq "USDT" )) {
                $cex_bid_price_3 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_3,$coin) + 0.00010000;
                $cex_ask_price_3 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_3,$coin) - 0.00010000;
            } elsif ( $coin eq "ETH" ) {
                $cex_bid_price_3 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_3,$coin) + 0.00000010;
                $cex_ask_price_3 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_3,$coin) - 0.00000010;
            } else {
                $cex_bid_price_3 = calc_bestprice_sum($mandala_depth->{'bids'},$maxsum_3,$coin) + 0.00000001;
                $cex_ask_price_3 = calc_bestprice_sum($mandala_depth->{'asks'},$maxsum_3,$coin) - 0.00000001;
            }
            if ( ( $cex_bid_price_3 eq "0.00000001" ) || ( $cex_bid_price_3 > $maxbidprice ) ) { $cex_bid_price_3 = $maxbidprice; }
            if ( ( $cex_ask_price_3 eq "0.00000001" ) || ( $cex_ask_price_3 < $minaskprice ) ) { $cex_ask_price_3 = $minaskprice; }

            #print "$cex_ask_price_1 $cex_ask_price_2 $cex_ask_price_3\n";
            mandala_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
            mandala_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
            mandala_setprice($base,$coin,$cex_bid_price_3,$cex_ask_price_3,$quantity_3);
        }
    }

} elsif ( $api eq "crex24" ) {
    my $json = read_file("$cwd/mpm.conf.crex24");
    my $marginsconf = decode_json($json);
    #my $marginadd = binance_volat();
    my $marginadd = 0;
    my $nonce = time();

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_1'} + $marginadd/5);
        my $bidmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_2'} + $marginadd/15);
        my $askmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_1'} + $marginadd/5);
        my $askmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_2'} + $marginadd/15);
        my $quantity_1 = $marginsconf->{$coin}{'quantity_1'};
        my $quantity_2 = $marginsconf->{$coin}{'quantity_2'};
        my $maxsum_1 = $marginsconf->{$coin}{'maxsum_1'};
        my $maxsum_2 = $marginsconf->{$coin}{'maxsum_2'};

        $nonce = $nonce+1;
        crex24_cancelorders($base,$coin,$nonce);

        my $binance_book_price = decode_json(binance_book_price($base,$coin));
        my $cex_price = sprintf("%.8f", ($binance_book_price->{'bidPrice'} + $binance_book_price->{'askPrice'})/2);
        my $crex24_depth = decode_json(crex24_depth($base,$coin));

        if ( $crex24_depth ne "1" ) {
            my $maxbidprice = sprintf("%.7f", ($cex_price - $cex_price * $bidmargin_1));
            my $minaskprice = sprintf("%.7f", ($cex_price + $cex_price * $askmargin_1));
            $cex_bid_price_1 = sprintf("%.7f", (calc_bestprice_crex24_sum($crex24_depth->{'buyLevels'},$maxsum_1,$coin) + 0.0000001));
            $cex_ask_price_1 = sprintf("%.7f", (calc_bestprice_crex24_sum($crex24_depth->{'sellLevels'},$maxsum_1,$coin) - 0.0000001));
            if ( ( $cex_bid_price_1 eq "0.0000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = $maxbidprice; }
            if ( ( $cex_ask_price_1 eq "0.0000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = $minaskprice; }

            $maxbidprice = sprintf("%.7f", ($cex_price - $cex_price * $bidmargin_2));
            $minaskprice = sprintf("%.7f", ($cex_price + $cex_price * $askmargin_2));
            $cex_bid_price_2 = sprintf("%.7f", (calc_bestprice_crex24_sum($crex24_depth->{'buyLevels'},$maxsum_2,$coin) + 0.0000001));
            $cex_ask_price_2 = sprintf("%.7f", (calc_bestprice_crex24_sum($crex24_depth->{'sellLevels'},$maxsum_2,$coin) - 0.0000001));
            if ( ( $cex_bid_price_2 eq "0.0000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
            if ( ( $cex_ask_price_2 eq "0.0000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }

            $nonce = $nonce+1;
            crex24_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1,$nonce);
            $nonce = $nonce+2;
            crex24_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2,$nonce);
        }
    }

} elsif ( $api eq "bitvavo" ) {
    my $json = read_file("$cwd/mpm.conf.bitvavo.$base");
    my $marginsconf = decode_json($json);
    #my $marginadd = binance_volat();
    my $marginadd = 0;

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_1'} + $marginadd/50);
        my $bidmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_2'} + $marginadd/25);
        my $bidmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_3'} + $marginadd/10);
        my $askmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_1'} + $marginadd/50);
        my $askmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_2'} + $marginadd/25);
        my $askmargin_3 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_3'} + $marginadd/10);
        my $quantity_1 = $marginsconf->{$coin}{'quantity_1'};
        my $quantity_2 = $marginsconf->{$coin}{'quantity_2'};
        my $quantity_3 = $marginsconf->{$coin}{'quantity_3'};
        my $maxsum_1 = $marginsconf->{$coin}{'maxsum_1'};
        my $maxsum_2 = $marginsconf->{$coin}{'maxsum_2'};
        my $maxsum_3 = $marginsconf->{$coin}{'maxsum_3'};

        bitvavo_cancelorders($base,$coin);

#        my $vav_btc_eur_price = decode_json(bitvavo_book_price("BTC","EUR"));
#        my $btc_eur_price = sprintf("%.2f", ($vav_btc_eur_price->{'bid'} + $vav_btc_eur_price->{'ask'})/2);
#        my $binance_book_price = decode_json(binance_book_price($base,"BTC"));
#        my $cex_price = sprintf("%.5f", ($binance_book_price->{'bidPrice'} + $binance_book_price->{'askPrice'})/2*$btc_eur_price);
        my $bitvavo_book_price = decode_json(bitvavo_book_price($base,$coin));
        my $cex_price = sprintf("%.5f", ($bitvavo_book_price->{'bid'} + $bitvavo_book_price->{'ask'})/2);
        my $bitvavo_depth = decode_json(bitvavo_depth($base,$coin));
#        print "btceur: $btc_eur_price, cex: $cex_price\n";

        if ( ($bitvavo_depth ne "1") && ($bitvavo_book_price ne "1") ) {
            my $maxbidprice = sprintf("%.5f", ($cex_price - $cex_price * $bidmargin_1));
            my $minaskprice = sprintf("%.5f", ($cex_price + $cex_price * $askmargin_1));
            $cex_bid_price_1 = sprintf("%.5f", (calc_bestprice_sum($bitvavo_depth->{'bids'},$maxsum_1,$coin) + 0.00001));
            $cex_ask_price_1 = sprintf("%.5f", (calc_bestprice_sum($bitvavo_depth->{'asks'},$maxsum_1,$coin) - 0.00001));
            if ( ( $cex_bid_price_1 eq "0.0001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = $maxbidprice; }
            if ( ( $cex_ask_price_1 eq "0.0001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = $minaskprice; }

            $maxbidprice = sprintf("%.5f", ($cex_price - $cex_price * $bidmargin_2));
            $minaskprice = sprintf("%.5f", ($cex_price + $cex_price * $askmargin_2));
            $cex_bid_price_2 = sprintf("%.5f", (calc_bestprice_sum($bitvavo_depth->{'bids'},$maxsum_2,$coin) + 0.00001));
            $cex_ask_price_2 = sprintf("%.5f", (calc_bestprice_sum($bitvavo_depth->{'asks'},$maxsum_2,$coin) - 0.00001));
            if ( ( $cex_bid_price_2 eq "0.0001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
            if ( ( $cex_ask_price_2 eq "0.0001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }

            $maxbidprice = sprintf("%.5f", ($cex_price - $cex_price * $bidmargin_3));
            $minaskprice = sprintf("%.5f", ($cex_price + $cex_price * $askmargin_3));
            $cex_bid_price_3 = sprintf("%.5f", (calc_bestprice_sum($bitvavo_depth->{'bids'},$maxsum_3,$coin) + 0.00001));
            $cex_ask_price_3 = sprintf("%.5f", (calc_bestprice_sum($bitvavo_depth->{'asks'},$maxsum_3,$coin) - 0.00001));
            if ( ( $cex_bid_price_3 eq "0.0001" ) || ( $cex_bid_price_3 > $maxbidprice ) ) { $cex_bid_price_3 = $maxbidprice; }
            if ( ( $cex_ask_price_3 eq "0.0001" ) || ( $cex_ask_price_3 < $minaskprice ) ) { $cex_ask_price_3 = $minaskprice; }

            bitvavo_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
            bitvavo_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
            bitvavo_setprice($base,$coin,$cex_bid_price_3,$cex_ask_price_3,$quantity_3);
        }
    }

} elsif ( $api eq "coinex" ) {
    my $json = read_file("$cwd/mpm.conf.coinex");
    my $marginsconf = decode_json($json);
    #my $marginadd = binance_volat();
    my $marginadd = 0;

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_1'} + $marginadd/15);
        my $bidmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'bidmargin_2'} + $marginadd/30);
        my $askmargin_1 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_1'} + $marginadd/15);
        my $askmargin_2 = sprintf("%.4f", $marginsconf->{$coin}{'askmargin_2'} + $marginadd/30);
        my $quantity_1 = $marginsconf->{$coin}{'quantity_1'};
        my $quantity_2 = $marginsconf->{$coin}{'quantity_2'};
        my $maxsum_1 = $marginsconf->{$coin}{'maxsum_1'};
        my $maxsum_2 = $marginsconf->{$coin}{'maxsum_2'};

        coinex_cancelorders($base,$coin);

        my $coinex_latest_price = decode_json(coinex_latest_price($base.$coin))->{'data'}{'ticker'};
        my $cex_price = sprintf("%.8f", ($coinex_latest_price->{'buy'} + $coinex_latest_price->{'sell'})/2);
        #print "coinex: $cex_price\n";

#        my $binance_book_price = decode_json(binance_book_price($base,$coin));
#        if ( $coin eq "BTC" ) {
#            $cex_price = sprintf("%.8f", ($binance_book_price->{'bidPrice'} + $binance_book_price->{'askPrice'})/2);
#            print "binance: $cex_price\n";
#        } elsif ( $coin eq "USDT" ) {
#            $cex_price = sprintf("%.4f", ($binance_book_price->{'bidPrice'} + $binance_book_price->{'askPrice'})/2);
#            print "binance: $cex_price\n";
#        } else {
#            $cex_price = decode_json(coinex_latest_price($base.$coin))->{'data'}{'ticker'}{'last'};
#        }
        my $coinex_depth = coinex_depth($base,$coin);

        if ( $coinex_depth ne "1" ) {
            my $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_1));
            my $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_1));
            if ( $coin eq "USDT" ) {
                $cex_bid_price_1 = sprintf("%.4f", (calc_bestprice_sum($coinex_depth->{'bids'},$maxsum_1,$coin) + 0.00010000));
                $cex_ask_price_1 = sprintf("%.4f", (calc_bestprice_sum($coinex_depth->{'asks'},$maxsum_1,$coin) - 0.00010000));
            } else {
                $cex_bid_price_1 = sprintf("%.8f", (calc_bestprice_sum($coinex_depth->{'bids'},$maxsum_1,$coin) + 0.00000001));
                $cex_ask_price_1 = sprintf("%.8f", (calc_bestprice_sum($coinex_depth->{'asks'},$maxsum_1,$coin) - 0.00000001));
            }
            if ( ( $cex_bid_price_1 eq "0.00000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = $maxbidprice; }
            if ( ( $cex_ask_price_1 eq "0.00000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = $minaskprice; }

            $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin_2));
            $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askmargin_2));
            if ( $coin eq "USDT" ) {
                $cex_bid_price_2 = sprintf("%.4f", (calc_bestprice_sum($coinex_depth->{'bids'},$maxsum_2,$coin) + 0.00010000));
                $cex_ask_price_2 = sprintf("%.4f", (calc_bestprice_sum($coinex_depth->{'asks'},$maxsum_2,$coin) - 0.00010000));
            } else {
                $cex_bid_price_2 = sprintf("%.8f", (calc_bestprice_sum($coinex_depth->{'bids'},$maxsum_2,$coin) + 0.00000001));
                $cex_ask_price_2 = sprintf("%.8f", (calc_bestprice_sum($coinex_depth->{'asks'},$maxsum_2,$coin) - 0.00000001));
            }
            if ( ( $cex_bid_price_2 eq "0.00000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
            if ( ( $cex_ask_price_2 eq "0.00000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }

            coinex_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
            coinex_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
        }
    }

} elsif ( $api eq "vcc" ) {
    my $json = read_file("$cwd/mpm.conf.vcc");
    my $marginsconf = decode_json($json);

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin = $marginsconf->{$coin}{'bidmargin'};
        my $askmargin = $marginsconf->{$coin}{'askmargin'};
        my $bidminmargin = $marginsconf->{$coin}{'bidminmargin'};
        my $askminmargin = $marginsconf->{$coin}{'askminmargin'};
        my $quantity_1 = $marginsconf->{$coin}{'quantity'};
        my $quantity_2 = $quantity_1/10;

        vcc_cancelorders($base,$coin);

        my $binance_book_price = decode_json(binance_book_price($base,$coin));
        my $cex_price = sprintf("%.8f", ($binance_book_price->{'bidPrice'} + $binance_book_price->{'askPrice'})/2);
        my $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidminmargin));
        my $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askminmargin));
        my $vcc_depth = vcc_depth($base,$coin);

        $cex_bid_price_1 = sprintf("%.8f", (calc_bestprice($vcc_depth->{'bids'},$quantity_1,$coin) + 0.00000001));
        $cex_ask_price_1 = sprintf("%.8f", (calc_bestprice($vcc_depth->{'asks'},$quantity_1,$coin) - 0.00000001));
        if ( ( $cex_bid_price_1 eq "0.00000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin)); }
        if ( ( $cex_ask_price_1 eq "0.00000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = sprintf("%.8f", ($cex_price + $cex_price * $askmargin)); }

        $cex_bid_price_2 = sprintf("%.8f", (calc_bestprice($vcc_depth->{'bids'},$quantity_2,$coin) + 0.00000001));
        $cex_ask_price_2 = sprintf("%.8f", (calc_bestprice($vcc_depth->{'asks'},$quantity_2,$coin) - 0.00000001));
        if ( ( $cex_bid_price_2 eq "0.00000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
        if ( ( $cex_ask_price_2 eq "0.00000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }
        if ( $cex_ask_price_2 > $cex_ask_price_1 ) { $cex_ask_price_2 = $cex_ask_price_1; }
        if ( $cex_bid_price_2 < $cex_bid_price_1 ) { $cex_bid_price_2 = $cex_bid_price_1; }

        vcc_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
        vcc_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
    }

} else {
    print "API not found\n";
}

