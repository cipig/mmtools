#!/usr/bin/perl

use warnings;
use LWP::UserAgent;
use JSON;
use JSON::RPC::Legacy::Client;
use File::Slurp qw(read_file);
use File::Basename;
use List::Util qw[min max];
use MIME::Base64;
use Digest::SHA qw(hmac_sha256_hex hmac_sha512_base64);
use Digest::MD5 qw(md5_hex);
use Data::Dumper;

my $base = "KMD";
my $basepapid = "kmd-komodo";
#my $base = "LTC";
#my $basepapid = "ltc-litecoin";

my $api = $ARGV[0];
my $pubkey = $ARGV[1];
my $cwd = dirname($0);
my $useragent = "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36";
my $timeout = 10;

my $binance_apikey = "";
my $binance_seckey = "";
my $crex24_apikey = "";
my $crex24_seckey = decode_base64("");
my $coinex_accessid = "";
my $coinex_seckey = "";
my $vcc_apikey = "";
my $vcc_seckey = "";


sub paprika_latest_price {
    my $url = "https://api.coinpaprika.com/v1/price-converter?base_currency_id=".$_[1]."&quote_currency_id=".$_[0]."&amount=1";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub paprika_price {
    my $base = $_[0];
    my $rel = $_[1];
    my $amount = $_[2];
    my $url = "https://api.coinpaprika.com/v1/price-converter?base_currency_id=".$base."&quote_currency_id=".$rel."&amount=".$amount;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
        }
}


sub binance_latest_price {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.binance.com/api/v3/ticker/price?symbol=".$base.$coin;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
        }
}


sub binance_book_price {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.binance.com/api/v3/ticker/bookTicker?symbol=".$base.$coin;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub binance_kline {
    my $base = $_[0];
    my $coin = $_[1];
    my $interval = $_[2];
    my $url = "https://api.binance.com/api/v3/klines?symbol=".$base.$coin."&interval=".$interval."&limit=2";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub coinex_latest_price {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.coinex.com/v1/market/ticker?market=".$base.$coin;
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
        }
}


sub binance_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.binance.com/api/v3/depth?symbol=".$base.$coin."&limit=20";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return $resp->content;
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
        }
}


sub vcc_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://vcc.exchange/api/v2/orderbook/".$base."_".$coin."?depth=20";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return decode_json($resp->content)->{'data'};
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
        }
}


sub coinex_depth {
    my $base = $_[0];
    my $coin = $_[1];
    my $url = "https://api.coinex.com/v1/market/depth?market=".$base.$coin."&limit=10&merge=0";
    my $ua = LWP::UserAgent->new;
    $ua->agent($useragent);
    $ua->timeout($timeout);
    my $req = HTTP::Request->new(GET => $url);
    $req->header('content-type' => 'application/json');
    my $resp = $ua->request($req);
        if ($resp->is_success) {
            return decode_json($resp->content)->{'data'};
        } else {
            print "HTTP GET url: ", $url, "\n";
            #print "HTTP GET error code: ", $resp->code, "\n";
            print "HTTP GET error message: ", $resp->message, "\n";
            return 1;
        }
}


sub binance_getorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $command = "symbol=".$base.$coin."&timestamp=".time()*1000;
    my $signature = hmac_sha256_hex($command, $binance_seckey);
    my $url = "https://api.binance.com/api/v3/openOrders?".$command."&signature=".$signature;

    my $ua = LWP::UserAgent->new;
    my $req = HTTP::Request->new(GET => $url);
    $req->header('X-MBX-APIKEY' => $binance_apikey);
    my $resp = $ua->request($req);
    return $resp->content;
}


sub binance_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];

    my $ua = LWP::UserAgent->new;
    $req = HTTP::Request->new(DELETE => 'https://api.binance.com/api/v3/order');
    $req->header('X-MBX-APIKEY' => $binance_apikey);

    my $orders = decode_json(binance_getorders($base,$coin));
    foreach my $order( @$orders ) {
        my $orderid = $order->{'clientOrderId'};
        $command = "symbol=".$base.$coin."&origClientOrderId=".$orderid."&timestamp=".time()*1000;
        $signature = hmac_sha256_hex($command, $binance_seckey);
        $body = $command."&signature=".$signature;
        $req->content($body);
        $resp = $ua->request($req);
        #print $resp->content."\n";
    }
}


sub coinex_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];
    my $tonce = time()*1000;
    my $url = "https://api.coinex.com/v1/order/pending?";
    my $params = "access_id=".$coinex_accessid."&account_id=0&market=".$base.$coin."&tonce=".$tonce;
    my $authorization = uc(md5_hex($params."&secret_key=".$coinex_seckey));

    my $ua = LWP::UserAgent->new;
    $req = HTTP::Request->new(DELETE => $url.$params);
    $ua->agent($useragent);
    $req->header('authorization' => $authorization);
    $req->header('content-type' => 'application/json');
    $req->content();
    $resp = $ua->request($req);
    #print $resp->content;
}


sub vcc_getorders {
    my $base = lc($_[1]);
    my $coin = lc($_[0]);
    my $tonce = time()*1000;
    my $url = "https://vcc.exchange/api/v2/orders/open";
    my $params = '?currency='.$base.'&coin='.$coin;
    my $payload = "GET api/v2/orders/open".$params;
    my $signature = hmac_sha256_hex($payload, $vcc_seckey);

    my $ua = LWP::UserAgent->new;
    $req = HTTP::Request->new(GET => $url.$params);
    $ua->agent($useragent);
    $req->header('Authorization' => 'Bearer '.$vcc_apikey);
    $req->header('timestamp' => $tonce);
    $req->header('signature' => $signature);
    $req->content();
    $resp = $ua->request($req);
    return $resp->content;
}


sub vcc_cancelorder {
    my $order_id = $_[0];
    my $tonce = time()*1000;
    my $url = "https://vcc.exchange/api/v2/orders/".$order_id."/cancel";
    my $payload = "PUT api/v2/orders/".$order_id."/cancel";
    my $signature = hmac_sha256_hex($payload, $vcc_seckey);

    my $ua = LWP::UserAgent->new;
    $req = HTTP::Request->new(PUT => $url);
    $ua->agent($useragent);
    $req->header('Authorization' => 'Bearer '.$vcc_apikey);
    $req->header('timestamp' => $tonce);
    $req->header('signature' => $signature);
    $req->content();
    $resp = $ua->request($req);
    #print $resp->content;
}


sub vcc_cancelorders {
    my $base = lc($_[1]);
    my $coin = lc($_[0]);
    my $orders = decode_json(vcc_getorders($coin,$base));
    for my $order( @{$orders->{data}{data}} ){
        vcc_cancelorder($order->{id});
    }
}


sub vcc_cancelallorders {
    my $tonce = time()*1000;
    my $url = "https://vcc.exchange/api/v2/orders/cancel-all";
    my $payload = "PUT api/v2/orders/cancel-all";
    my $signature = hmac_sha256_hex($payload, $vcc_seckey);

    my $ua = LWP::UserAgent->new;
    $req = HTTP::Request->new(PUT => $url);
    $ua->agent($useragent);
    $req->header('Authorization' => 'Bearer '.$vcc_apikey);
    $req->header('timestamp' => $tonce);
    $req->header('signature' => $signature);
    $req->content();
    $resp = $ua->request($req);
    #print $resp->content;
}


sub crex24_cancelorders {
    my $base = $_[0];
    my $coin = $_[1];
    my $urlpath = "/v2/trading/cancelOrdersByInstrument";
    my $nonce = time();
    my $body = '{"instruments":["'.$base.'-'.$coin.'"]}';
    my $command = $urlpath . $nonce . $body;
    my $signature = hmac_sha512_base64($command,$crex24_seckey);
    while (length($signature) % 4) {
        $signature .= '=';
    }

    my $ua = LWP::UserAgent->new;
    $req = HTTP::Request->new(POST => 'https://api.crex24.com/v2/trading/cancelOrdersByInstrument');
    $req->header('X-CREX24-API-KEY' => $crex24_apikey,
                 'X-CREX24-API-NONCE' => $nonce,
                 'X-CREX24-API-SIGN' => $signature);

    $req->content($body);
    my $resp = $ua->request($req);
    #print $resp->content."\n";
    sleep(1);
}


sub binance_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = undef;
    my $ask = undef;
    if ( $coin eq "ETH" ) {
        $bid = sprintf("%.6f",$_[2]);
        $ask = sprintf("%.6f",$_[3]);
    } else {
        $bid = sprintf("%.7f",$_[2]);
        $ask = sprintf("%.7f",$_[3]);
    }
    my $quantity = sprintf("%u",$_[4]);

    my $ua = LWP::UserAgent->new;
    my $req = HTTP::Request->new(POST => 'https://api.binance.com/api/v3/order');
    $req->header('X-MBX-APIKEY' => $binance_apikey);

    print "$base/$coin size ".sprintf("%04d",$quantity);

    if ( defined $bid ) {
        my $command = "symbol=".$base.$coin."&side=BUY&type=LIMIT_MAKER&newOrderRespType=RESULT&quantity=".$quantity."&price=".$bid."&newClientOrderId=mybuyid".$quantity."&timestamp=".time()*1000;
        my $signature = hmac_sha256_hex($command, $binance_seckey);
        my $body = $command."&signature=".$signature;
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " bid ".$bid;
        } else {
            print " bid 0.0000000";
            #print " ".$resp->content;
        }
    }

    if ( defined $ask ) {
	my $command = "symbol=".$base.$coin."&side=SELL&type=LIMIT_MAKER&newOrderRespType=RESULT&quantity=".$quantity."&price=".$ask."&newClientOrderId=mysellid".$quantity."&timestamp=".time()*1000;
	my $signature = hmac_sha256_hex($command, $binance_seckey);
        my $body = $command."&signature=".$signature;
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " ask ".$ask."\n";
        } else {
            print " ask 0.0000000\n";
            #print " ".$resp->content."\n";
        }
    }
}


sub crex24_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = $_[2];
    my $ask = $_[3];
    my $quantity = sprintf("%u",$_[4]);
    my $urlpath = "/v2/trading/placeOrder";

    print "$base/$coin size ".sprintf("%03d",$quantity);

    if ( defined $bid ) {
        my $nonce = time();
        my $body = '{"instrument":"'.$base.'-'.$coin.'","side":"buy","volume":'.$quantity.',"price":'.$bid.'}';
        my $command = $urlpath . $nonce . $body;
        my $signature = hmac_sha512_base64($command,$crex24_seckey);
        while (length($signature) % 4) {
            $signature .= '=';
        }
        my $ua = LWP::UserAgent->new;
        $req = HTTP::Request->new(POST => 'https://api.crex24.com/v2/trading/placeOrder');
        $req->header('X-CREX24-API-KEY' => $crex24_apikey,
                     'X-CREX24-API-NONCE' => $nonce,
                     'X-CREX24-API-SIGN' => $signature);
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " bid ".$bid;
        } else {
            print " bid 0.0000000";
            #print " ".$resp->content;
        }
        sleep(1);
    }

    if ( defined $ask ) {
        my $nonce = time();
        my $body = '{"instrument":"'.$base.'-'.$coin.'","side":"sell","volume":'.$quantity.',"price":'.$ask.'}';
        my $command = $urlpath . $nonce . $body;
        my $signature = hmac_sha512_base64($command,$crex24_seckey);
        while (length($signature) % 4) {
            $signature .= '=';
        }
        my $ua = LWP::UserAgent->new;
        $req = HTTP::Request->new(POST => 'https://api.crex24.com/v2/trading/placeOrder');
        $req->header('X-CREX24-API-KEY' => $crex24_apikey,
                     'X-CREX24-API-NONCE' => $nonce,
                     'X-CREX24-API-SIGN' => $signature);
        $req->content($body);
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " ask ".$ask."\n";
        } else {
            print " ask 0.0000000\n";
            #print " ".$resp->content."\n";
        }
        sleep(1);
    }
}


sub vcc_setprice {
    my $base = lc($_[1]);
    my $coin = lc($_[0]);
    my $bid = $_[2];
    my $ask = $_[3];
    my $quantity = sprintf("%u",$_[4]);
    my $url = "https://vcc.exchange/api/v2/orders";

    print "$_[0]/$_[1] size ".sprintf("%03d",$quantity);

    if ( defined $bid ) {
        my $tonce = time()*1000;
        my $params = '?currency='.$base.'&coin='.$coin.'&trade_type=buy&type=limit&quantity='.$quantity.'&price='.$bid;
        my $payload = "POST api/v2/orders".$params;
        my $signature = hmac_sha256_hex($payload, $vcc_seckey);
        my $ua = LWP::UserAgent->new;
        $req = HTTP::Request->new(POST => $url.$params);
        $ua->agent($useragent);
        $req->header('Authorization' => 'Bearer '.$vcc_apikey);
        $req->header('timestamp' => $tonce);
        $req->header('signature' => $signature);
        $req->header('content-type' => 'application/json');
        $req->content();
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " bid ".$bid;
        } else {
            print " bid 0.00000000";
            #print " ".$resp->content;
        }
    }

    if ( defined $ask ) {
        my $tonce = time()*1000;
        my $params = '?currency='.$base.'&coin='.$coin.'&trade_type=sell&type=limit&quantity='.$quantity.'&price='.$ask;
        my $payload = "POST api/v2/orders".$params;
        my $signature = hmac_sha256_hex($payload, $vcc_seckey);
        my $ua = LWP::UserAgent->new;
        $req = HTTP::Request->new(POST => $url.$params);
        $ua->agent($useragent);
        $req->header('Authorization' => 'Bearer '.$vcc_apikey);
        $req->header('timestamp' => $tonce);
        $req->header('signature' => $signature);
        $req->header('content-type' => 'application/json');
        $req->content();
        my $resp = $ua->request($req);
        if ($resp->is_success) {
            print " ask ".$ask."\n";
        } else {
            print " ask 0.00000000\n";
            #print " ".$resp->content."\n";
        }
    }
}


sub coinex_setprice {
    my $base = $_[0];
    my $coin = $_[1];
    my $bid = $_[2];
    my $ask = $_[3];
    my $quantity = sprintf("%u",$_[4]);
    my $url = "https://api.coinex.com/v1/order/limit";

    print "$base/$coin size ".sprintf("%03d",$quantity);

    if ( defined $bid ) {
        my $tonce = time()*1000;
        my $body = '{ "access_id":"'.$coinex_accessid.'","amount":"'.$quantity.'","price":"'.$bid.'","type":"buy","market":"'.$base.$coin.'","tonce":'.$tonce.' }';
        my $signtext = "access_id=".$coinex_accessid."&amount=".$quantity."&market=".$base.$coin."&price=".$bid."&tonce=".$tonce."&type=buy&secret_key=".$coinex_seckey;
        my $authorization = uc(md5_hex($signtext));

        my $ua = LWP::UserAgent->new;
        $req = HTTP::Request->new(POST => $url);
        $ua->agent($useragent);
        $ua->timeout($timeout);
        $req->header('authorization' => $authorization);
        $req->header('content-type' => 'application/json');
        $req->content($body);
        $resp = $ua->request($req);
        my $code = decode_json($resp->content)->{'code'};
        if ($code eq "0") {
            print " bid ".$bid;
        } else {
            print " bid 0.00000000";
            #print " ".$resp->content;
        }
        sleep 1;
    }

    if ( defined $ask ) {
        my $tonce = time()*1000;
        my $body = '{ "access_id":"'.$coinex_accessid.'","amount":"'.$quantity.'","price":"'.$ask.'","type":"sell","market":"'.$base.$coin.'","tonce":'.$tonce.' }';
        my $signtext = "access_id=".$coinex_accessid."&amount=".$quantity."&market=".$base.$coin."&price=".$ask."&tonce=".$tonce."&type=sell&secret_key=".$coinex_seckey;
        my $authorization = uc(md5_hex($signtext));

        my $ua = LWP::UserAgent->new;
        $req = HTTP::Request->new(POST => $url);
        $ua->agent($useragent);
        $ua->timeout($timeout);
        $req->header('authorization' => $authorization);
        $req->header('content-type' => 'application/json');
        $req->content($body);
        $resp = $ua->request($req);
        my $code = decode_json($resp->content)->{'code'};
        if ($code eq "0") {
            print " ask ".$ask."\n";
        } else {
            print " ask 0.00000000\n";
            #print " ".$resp->content."\n";
        }
    }
}


sub dex_setprice {
    my $price = $_[2];
    my $bid = undef;
    my $ask = undef;
    my $command = undef;

    if ( defined $marginsconf->{$_[1]}{'askmargin'} ) {
        my $askmargin = $marginsconf->{$_[1]}{'askmargin'} + $_[3];
        $ask = sprintf("%.8f", $price + $price * $askmargin);
    }
    if ( defined $marginsconf->{$_[1]}{'bidmargin'} ) {
        my $bidmargin = $marginsconf->{$_[1]}{'bidmargin'} + $_[3];
        $bid = sprintf("%.8f", 1 / ($price - $price * $bidmargin));
    }

    my $ua = LWP::UserAgent->new;
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    print "$_[1]/$_[0] ";
    if ( defined $ask ) {
	$command = '{"userpass":"'.$userpass.'","method":"setprice","base":"'.$_[1].'","rel":"'.$_[0].'","price":'.$ask.',"max":true}';
        $req->content($command);
        my $resp = $ua->request($req);
        my $uuid = from_json($resp->content)->{'result'}{'uuid'};
        if ( !defined $uuid ) { $uuid = "error"; }
        print "ask ".sprintf("%.8f",$ask)." ";
    }

    if ( defined $bid ) {
	$command = '{"userpass":"'.$userpass.'","method":"setprice","base":"'.$_[0].'","rel":"'.$_[1].'","price":'.$bid.',"max":true}';
        $req->content($command);
        $resp = $ua->request($req);
        my $uuid = from_json($resp->content)->{'result'}{'uuid'};
        if ( !defined $uuid ) { $uuid = "error"; }
        print "bid ".sprintf("%.8f",1/$bid);
    }
    print "\n";
}


sub dexp2p_setprice {
    my $base = $_[0];
    my $rel = $_[1];
    my $base_price = $_[2];
    my $rel_price = $_[3];
    my $base_balance = $_[4];
    my $rel_balance = $_[5];

    if ( defined $marginsconf->{$_[1]}{'askmargin'} ) {
        $ask = sprintf("%.8f", $base_price + $base_price * $marginsconf->{$_[1]}{'askmargin'});
    }
    if ( defined $marginsconf->{$_[1]}{'bidmargin'} ) {
        $bid = sprintf("%.8f", $rel_price + $rel_price * $marginsconf->{$_[1]}{'bidmargin'});
    }

    my $client = new JSON::RPC::Legacy::Client;
    $client->ua->credentials('localhost:14869', 'jsonrpc', 'dexp2p' => 'KeWt2phRPXUPGX');
    my $uri = 'http://localhost:14869/';

    if ( defined $ask ) {
        my $obj = { method => 'DEX_broadcast', params => ['hello','0',$rel,$base,$pubkey,''.$rel_balance,''.$ask] };
        my $res = $client->call( $uri, $obj );
        if ($res){
           if ($res->is_error) { print "Error : ", Dumper($res->error_message); }
           #else { print Dumper($res->result); }
           else { print $rel."/".$base." ".$rel_balance." ".$ask."\n"; }
        } else {
           print $client->status_line;
        }
    }

    if ( defined $bid ) {
        my $obj = { method => 'DEX_broadcast', params => ['hello','0',$base,$rel,$pubkey,''.$base_balance,''.$bid] };
        my $res = $client->call( $uri, $obj );
        if ($res){
           if ($res->is_error) { print "Error : ", Dumper($res->error_message); }
           #else { print Dumper($res->result); }
           else { print $base."/".$rel." ".$base_balance." ".$bid."\n"; }
        } else {
           print $client->status_line;
        }
    }
}


sub dexp2p_deleteprice {
    my $base = $_[0];
    my $rel = $_[1];

    my $client = new JSON::RPC::Legacy::Client;
    $client->ua->credentials('localhost:14869', 'jsonrpc', 'dexp2p' => 'KeWt2phRPXUPGX');
    my $uri = 'http://localhost:14869/';

    my $obj = { method => 'DEX_cancel', params => ['','',$base,$rel] };
    my $res = $client->call( $uri, $obj );
    if ($res){
       if ($res->is_error) { print "Error : ", Dumper($res->error_message); }
       #else { print Dumper($res->result); }
    } else {
       print $client->status_line;
    }

    $obj = { method => 'DEX_cancel', params => ['','',$rel,$base] };
    $res = $client->call( $uri, $obj );
    if ($res){
       if ($res->is_error) { print "Error : ", Dumper($res->error_message); }
       #else { print Dumper($res->result); }
    } else {
       print $client->status_line;
    }
}


sub dex_deleteprice {
    my $ua = LWP::UserAgent->new;
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    $command = '{"userpass":"'.$userpass.'","method":"cancel_all_orders","cancel_by":{"type":"Pair","data":{"base":"'.$_[1].'","rel":"'.$_[0].'"}}}';
    $req->content($command);
    my $resp = $ua->request($req);
    print "$_[0]/$_[1] ".$resp->content;

    $command = '{"userpass":"'.$userpass.'","method":"cancel_all_orders","cancel_by":{"type":"Pair","data":{"base":"'.$_[0].'","rel":"'.$_[1].'"}}}';
    $req->content($command);
    $resp = $ua->request($req);
    print " ".$resp->content."\n";
}


sub dex_gettradefee {
    my $coin = $_[0];
    my $ua = LWP::UserAgent->new;
    my $req = HTTP::Request->new(POST => 'http://127.0.0.1:7783');
    $req->content_type('application/x-www-form-urlencoded');

    $command = '{"userpass":"'.$userpass.'","method":"get_trade_fee","coin":"'.$coin.'"}';
    $req->content($command);
    my $resp = $ua->request($req);
    return from_json($resp->content)->{'result'}{'amount'};
}


sub calc_bestprice {
    my $quantity = $_[1];
    my $coin = $_[2];
    foreach (@{$_[0]}) {
        my @array = $_;
        my $price = $array[0][0];
        my $volume = $array[0][1];
        if ( $volume >= $quantity ) {
            return $price;
            last;
        }
    }
}


sub binance_volat {
    my $marginadd_1 = 0.01;
    my $marginadd_2 = 0.01;
    my $marginadd_3 = 0.01;
    my $marginadd_4 = 0.01;
    my $kline_1 = binance_kline("KMD","BTC","3m");
    if ( $kline_1 ne "1" ) {
        $marginadd_2 = from_json($kline_1)->[0][2] / from_json($kline_1)->[0][3] - 1;
        $marginadd_1 = from_json($kline_1)->[1][2] / from_json($kline_1)->[1][3] - 1;
    }
    print "marginadd_1: ".sprintf("%.3f", $marginadd_1)."  marginadd_2: ".sprintf("%.3f", $marginadd_2)."\n";
    return max($marginadd_1,$marginadd_2);
}


if ( $api eq "dex" ) {
    $userpass =  $ENV{'userpass'};
    my $json = read_file("$cwd/mpm.conf.dex.$base");
    $marginsconf = decode_json($json);
#    my $marginadd = binance_volat();
    my $marginadd = 0;
    foreach my $coin ( keys %{$marginsconf} ) {
        my $price = undef;
        my $papid = $marginsconf->{$coin}{'papid'};
        my $tradefee = dex_gettradefee($coin);
        my $maxfee = $marginsconf->{$coin}{'maxfee'};
        if ( !defined $maxfee ) { $maxfee = "100"; }

        if ( ( $coin eq "BTC" ) || ( $coin eq "ETH" ) ) {
            my $binance_price = binance_book_price($base,$coin);
            if ( $binance_price ne "1" ) {
                my $binance_book_price = decode_json($binance_price);
                my $cex_price = sprintf("%.8f", ($binance_book_price->{'bidPrice'} + $binance_book_price->{'askPrice'})/2);
                $price = 1 / $cex_price;
            }
        }

        if ( !defined $price ) {
            my $coinprice = paprika_latest_price($basepapid,$papid);
            if ( $coinprice ne "1" ) { $price = from_json($coinprice)->{'price'}; }
        }

        if ( (defined $price) && ($tradefee < $maxfee) ) {
            dex_setprice($base,$coin,$price,$marginadd);
        } else {
            dex_deleteprice($base,$coin);
        }
    }

} elsif ( $api eq "dexp2p" ) {
    my $json = read_file("$cwd/mpm.conf.dexp2p");
    my $relamount = 0.07;
    my $baseamount = 1000;
    $marginsconf = decode_json($json);
    foreach my $coin ( keys %{$marginsconf} ) {
        my $papid = $marginsconf->{$coin}{'papid'};
        my $baseprice = from_json(paprika_price($papid,$basepapid,$relamount))->{'price'};
        my $relprice = from_json(paprika_price($basepapid,$papid,$baseamount))->{'price'};
        dexp2p_deleteprice("KMD",$coin);
        dexp2p_setprice("KMD",$coin,$baseprice,$relprice,$baseamount,$relamount);
    }

} elsif ( $api eq "binance" ) {
    my $json = read_file("$cwd/mpm.conf.binance");
    my $marginsconf = decode_json($json);

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin = $marginsconf->{$coin}{'bidmargin'};
        my $askmargin = $marginsconf->{$coin}{'askmargin'};
        my $bidminmargin = $marginsconf->{$coin}{'bidminmargin'};
        my $askminmargin = $marginsconf->{$coin}{'askminmargin'};
        my $quantity_1 = $marginsconf->{$coin}{'quantity'};
        my $quantity_2 = $quantity_1/10;

        binance_cancelorders($base,$coin);

        my $binance_book_price = decode_json(binance_book_price($base,$coin));
        my $cex_price = sprintf("%.8f", ($binance_book_price->{'bidPrice'} + $binance_book_price->{'askPrice'})/2);
        my $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidminmargin));
        my $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askminmargin));
        my $binance_depth = decode_json(binance_depth($base,$coin));

        if ( $coin eq "ETH" ) {
            $cex_bid_price_1 = calc_bestprice($binance_depth->{'bids'},$quantity_1,$coin) + 0.00000100;
            $cex_ask_price_1 = calc_bestprice($binance_depth->{'asks'},$quantity_1,$coin) - 0.00000100;
        } else {
            $cex_bid_price_1 = calc_bestprice($binance_depth->{'bids'},$quantity_1,$coin) + 0.00000010;
            $cex_ask_price_1 = calc_bestprice($binance_depth->{'asks'},$quantity_1,$coin) - 0.00000010;
        }
        if ( ( $cex_bid_price_1 eq "0.00000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin)); }
        if ( ( $cex_ask_price_1 eq "0.00000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = sprintf("%.8f", ($cex_price + $cex_price * $askmargin)); }

        if ( $coin eq "ETH" ) {
            $cex_bid_price_2 = calc_bestprice($binance_depth->{'bids'},$quantity_2,$coin) + 0.00000100;
            $cex_ask_price_2 = calc_bestprice($binance_depth->{'asks'},$quantity_2,$coin) - 0.00000100;
        } else {
            $cex_bid_price_2 = calc_bestprice($binance_depth->{'bids'},$quantity_2,$coin) + 0.00000010;
            $cex_ask_price_2 = calc_bestprice($binance_depth->{'asks'},$quantity_2,$coin) - 0.00000010;
        }
        if ( ( $cex_bid_price_2 eq "0.00000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
        if ( ( $cex_ask_price_2 eq "0.00000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }
        if ( $cex_ask_price_2 > $cex_ask_price_1 ) { $cex_ask_price_2 = $cex_ask_price_1; }
        if ( $cex_bid_price_2 < $cex_bid_price_1 ) { $cex_bid_price_2 = $cex_bid_price_1; }

        binance_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
        binance_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
    }

} elsif ( $api eq "crex24" ) {
    my $json = read_file("$cwd/mpm.conf.crex24");
    my $marginsconf = decode_json($json);

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin = $marginsconf->{$coin}{'bidmargin'};
        my $askmargin = $marginsconf->{$coin}{'askmargin'};
        my $bidminmargin = $marginsconf->{$coin}{'bidminmargin'};
        my $askminmargin = $marginsconf->{$coin}{'askminmargin'};
        my $quantity_1 = $marginsconf->{$coin}{'quantity'};
        my $quantity_2 = $quantity_1/10;

        my $binance_book_price = decode_json(binance_book_price($base,$coin));
        my $cex_price = sprintf("%.8f", ($binance_book_price->{'bidPrice'} + $binance_book_price->{'askPrice'})/2);
        my $cex_bid_price_1 = sprintf("%.7f", ($cex_price - $cex_price * $bidmargin));
        my $cex_ask_price_1 = sprintf("%.7f", ($cex_price + $cex_price * $askmargin));
        my $cex_bid_price_2 = sprintf("%.7f", ($cex_price - $cex_price * $bidminmargin));
        my $cex_ask_price_2 = sprintf("%.7f", ($cex_price + $cex_price * $askminmargin));

        crex24_cancelorders($base,$coin);
        crex24_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
        crex24_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
    }

} elsif ( $api eq "coinex" ) {
    my $json = read_file("$cwd/mpm.conf.coinex");
    my $marginsconf = decode_json($json);

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin = $marginsconf->{$coin}{'bidmargin'};
        my $askmargin = $marginsconf->{$coin}{'askmargin'};
        my $bidminmargin = $marginsconf->{$coin}{'bidminmargin'};
        my $askminmargin = $marginsconf->{$coin}{'askminmargin'};
        my $quantity_1 = $marginsconf->{$coin}{'quantity'};
        my $quantity_2 = $quantity_1/10;
        my $cex_price = undef;

        if ( $coin eq "BTC" ) {
            my $binance_book_price = decode_json(binance_book_price($base,$coin));
            my $binance_latest_price = sprintf("%.8f", ($binance_book_price->{'bidPrice'} + $binance_book_price->{'askPrice'})/2);
            $cex_price = $binance_latest_price;
        } else {
            $cex_price = decode_json(coinex_latest_price($base,$coin))->{'data'}{'ticker'}{'last'};
        }

        coinex_cancelorders($base,$coin);

        my $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidminmargin));
        my $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askminmargin));
        my $coinex_depth = coinex_depth($base,$coin);

        if ( $coinex_depth ne "1" ) {
            $cex_bid_price_1 = sprintf("%.8f", (calc_bestprice($coinex_depth->{'bids'},$quantity_1,$coin) + 0.00000001));
            $cex_ask_price_1 = sprintf("%.8f", (calc_bestprice($coinex_depth->{'asks'},$quantity_1,$coin) - 0.00000001));
            if ( ( $cex_bid_price_1 eq "0.00000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin)); }
            if ( ( $cex_ask_price_1 eq "0.00000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = sprintf("%.8f", ($cex_price + $cex_price * $askmargin)); }

            $cex_bid_price_2 = sprintf("%.8f", (calc_bestprice($coinex_depth->{'bids'},$quantity_2,$coin) + 0.00000001));
            $cex_ask_price_2 = sprintf("%.8f", (calc_bestprice($coinex_depth->{'asks'},$quantity_2,$coin) - 0.00000001));
            if ( ( $cex_bid_price_2 eq "0.00000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
            if ( ( $cex_ask_price_2 eq "0.00000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }
            if ( $cex_ask_price_2 > $cex_ask_price_1 ) { $cex_ask_price_2 = $cex_ask_price_1; }
            if ( $cex_bid_price_2 < $cex_bid_price_1 ) { $cex_bid_price_2 = $cex_bid_price_1; }

            coinex_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
            coinex_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
        }
    }

} elsif ( $api eq "vcc" ) {
    my $json = read_file("$cwd/mpm.conf.vcc");
    my $marginsconf = decode_json($json);

    foreach my $coin ( keys %{$marginsconf} ) {
        my $bidmargin = $marginsconf->{$coin}{'bidmargin'};
        my $askmargin = $marginsconf->{$coin}{'askmargin'};
        my $bidminmargin = $marginsconf->{$coin}{'bidminmargin'};
        my $askminmargin = $marginsconf->{$coin}{'askminmargin'};
        my $quantity_1 = $marginsconf->{$coin}{'quantity'};
        my $quantity_2 = $quantity_1/10;

        vcc_cancelorders($base,$coin);

        my $binance_book_price = decode_json(binance_book_price($base,$coin));
        my $cex_price = sprintf("%.8f", ($binance_book_price->{'bidPrice'} + $binance_book_price->{'askPrice'})/2);
        my $maxbidprice = sprintf("%.8f", ($cex_price - $cex_price * $bidminmargin));
        my $minaskprice = sprintf("%.8f", ($cex_price + $cex_price * $askminmargin));
        my $vcc_depth = vcc_depth($base,$coin);

        $cex_bid_price_1 = sprintf("%.8f", (calc_bestprice($vcc_depth->{'bids'},$quantity_1,$coin) + 0.00000001));
        $cex_ask_price_1 = sprintf("%.8f", (calc_bestprice($vcc_depth->{'asks'},$quantity_1,$coin) - 0.00000001));
        if ( ( $cex_bid_price_1 eq "0.00000001" ) || ( $cex_bid_price_1 > $maxbidprice ) ) { $cex_bid_price_1 = sprintf("%.8f", ($cex_price - $cex_price * $bidmargin)); }
        if ( ( $cex_ask_price_1 eq "0.00000001" ) || ( $cex_ask_price_1 < $minaskprice ) ) { $cex_ask_price_1 = sprintf("%.8f", ($cex_price + $cex_price * $askmargin)); }

        $cex_bid_price_2 = sprintf("%.8f", (calc_bestprice($vcc_depth->{'bids'},$quantity_2,$coin) + 0.00000001));
        $cex_ask_price_2 = sprintf("%.8f", (calc_bestprice($vcc_depth->{'asks'},$quantity_2,$coin) - 0.00000001));
        if ( ( $cex_bid_price_2 eq "0.00000001" ) || ( $cex_bid_price_2 > $maxbidprice ) ) { $cex_bid_price_2 = $maxbidprice; }
        if ( ( $cex_ask_price_2 eq "0.00000001" ) || ( $cex_ask_price_2 < $minaskprice ) ) { $cex_ask_price_2 = $minaskprice; }
        if ( $cex_ask_price_2 > $cex_ask_price_1 ) { $cex_ask_price_2 = $cex_ask_price_1; }
        if ( $cex_bid_price_2 < $cex_bid_price_1 ) { $cex_bid_price_2 = $cex_bid_price_1; }

        vcc_setprice($base,$coin,$cex_bid_price_1,$cex_ask_price_1,$quantity_1);
        vcc_setprice($base,$coin,$cex_bid_price_2,$cex_ask_price_2,$quantity_2);
    }

} else {
    print "API not found\n";
}

